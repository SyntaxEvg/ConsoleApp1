using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Security.Claims;
using System.Threading.Tasks;
using System.Web;
using HAS.Modules.UAS.Exceptions;
using HAS.Modules.UAS.Extensions;
using HAS.Modules.UAS.Helpers;
using HAS.Modules.UAS.ViewModels;
using HAS.Server.Hopex.Module.Adapter.SSP.Models;
using IdentityServer4.Extensions;
using IdentityServer4.Models;
using IdentityServer4.Services;
using IdentityServer4.Stores;
using Mega.Has.Commons;
using Mega.Has.Modules.UAS.Models;
using Mega.Has.Modules.UAS.Providers.Hopex;
using Mega.Has.Modules.UAS.Providers.Windows;
using Mega.Has.Modules.UAS.Services;
using Mega.Has.Modules.UAS.ViewModels;
using Mega.Has.WebSite;
using Mega.Has.WebSite.LoginWorkflow;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc.Rendering;
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Logging;
using Serilog;

namespace HAS.Modules.UAS.Services.Factories
{
    internal class ViewModelFactory : IViewModelFactory
    {
        private readonly IClientStore _clientStore;
        private readonly IClusterAdminClient _clusterAdminClient;
        private readonly IClusterConfiguration _clusterConfiguration;
        private readonly IExternalProviderService _externalProviderService;
        private readonly IHopexSSPClient _hopexSSPClient;
        private readonly IHttpContextAccessor _httpContextAccessor;
        private readonly IIdentityServerInteractionService _interactionService;
        private readonly ILogger<ViewModelFactory> _logger;
        private readonly IStringLocalizer S;

        public ViewModelFactory(
            IHopexSSPClient hopexSSPClient,
            IIdentityServerInteractionService interactionService,
            IExternalProviderService externalProviderService,
            IClusterConfiguration clusterConfiguration,
            IHttpContextAccessor httpContextAccessor,
            ILogger<ViewModelFactory> logger,
            IClusterAdminClient clusterAdminClient,
            IClientStore clientStore,
            IStringLocalizer<ViewModelFactory> s)
        {
            _hopexSSPClient = hopexSSPClient;
            _interactionService = interactionService;
            _externalProviderService = externalProviderService;
            _clusterConfiguration = clusterConfiguration;
            _httpContextAccessor = httpContextAccessor;
            _logger = logger;
            _clusterAdminClient = clusterAdminClient;
            _clientStore = clientStore;
            S = s;

            // ========== ЛОГИРОВАНИЕ ПРИ СОЗДАНИИ ==========
            Log.Information("##################################################");
            Log.Information("### ViewModelFactory СОЗДАН - DEBUG VERSION v1 ###");
            Log.Information("##################################################");
            
            try
            {
                Log.Information($"_hopexSSPClient = {(_hopexSSPClient != null ? _hopexSSPClient.GetType().FullName : "NULL")}");
                
                if (_hopexSSPClient != null)
                {
                    // Пробуем получить информацию о клиенте через reflection
                    var clientType = _hopexSSPClient.GetType();
                    Log.Information($"HopexSSPClient Assembly: {clientType.Assembly.FullName}");
                    Log.Information($"HopexSSPClient Assembly Location: {clientType.Assembly.Location}");
                    
                    // Пробуем получить приватные поля
                    foreach (var field in clientType.GetFields(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance))
                    {
                        try
                        {
                            var value = field.GetValue(_hopexSSPClient);
                            if (value != null)
                            {
                                var valueStr = value.ToString();
                                // Маскируем пароли
                                if (field.Name.ToLower().Contains("password") || field.Name.ToLower().Contains("secret"))
                                {
                                    valueStr = "***MASKED***";
                                }
                                Log.Information($"  Field '{field.Name}' ({field.FieldType.Name}): {valueStr}");
                            }
                        }
                        catch { }
                    }
                    
                    // Пробуем получить приватные свойства
                    foreach (var prop in clientType.GetProperties(System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public))
                    {
                        try
                        {
                            if (prop.CanRead)
                            {
                                var value = prop.GetValue(_hopexSSPClient);
                                if (value != null)
                                {
                                    var valueStr = value.ToString();
                                    if (prop.Name.ToLower().Contains("password") || prop.Name.ToLower().Contains("secret"))
                                    {
                                        valueStr = "***MASKED***";
                                    }
                                    Log.Information($"  Property '{prop.Name}' ({prop.PropertyType.Name}): {valueStr}");
                                }
                            }
                        }
                        catch { }
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Warning($"Ошибка при логировании _hopexSSPClient: {ex.Message}");
            }
            
            try
            {
                Log.Information($"_clusterConfiguration = {(_clusterConfiguration != null ? "OK" : "NULL")}");
                
                if (_clusterConfiguration != null)
                {
                    var runtime = _clusterConfiguration.RuntimeClusterSettings;
                    if (runtime != null)
                    {
                        Log.Information($"RuntimeClusterSettings.PublicAddress: {runtime.PublicAddress}");
                        Log.Information($"RuntimeClusterSettings.Mode: {runtime.Mode}");
                        
                        // Пробуем получить другие настройки через reflection
                        var runtimeType = runtime.GetType();
                        foreach (var prop in runtimeType.GetProperties())
                        {
                            try
                            {
                                if (prop.CanRead && prop.Name != "PublicAddress" && prop.Name != "Mode")
                                {
                                    var value = prop.GetValue(runtime);
                                    if (value != null)
                                    {
                                        var valueStr = value.ToString();
                                        if (prop.Name.ToLower().Contains("password") || prop.Name.ToLower().Contains("secret") || prop.Name.ToLower().Contains("connection"))
                                        {
                                            valueStr = "***MASKED***";
                                        }
                                        Log.Information($"  RuntimeSettings.{prop.Name}: {valueStr}");
                                    }
                                }
                            }
                            catch { }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Log.Warning($"Ошибка при логировании _clusterConfiguration: {ex.Message}");
            }
            
            Log.Information("### Конец инициализации ViewModelFactory ###");
        }

        public async Task<LoggedOutViewModel> BuildLoggedOutViewModelAsync(string logoutId)
        {
            var logout = await _interactionService.GetLogoutContextAsync(logoutId);

            if (logout == null)
            {
                throw new Exception("Logout context cannot be null.");
            }

            var automaticRedirectAfterSignOut = AccountOptions.AutomaticRedirectAfterSignOut;

            if (automaticRedirectAfterSignOut)
            {
                var providers = _externalProviderService.GetExternalProviders().ToList();

                var hopexProvider = providers.FirstOrDefault(x => x.AuthenticationScheme == "Hopex");
                var hopexProviderEnabled = hopexProvider == null || hopexProvider.Enabled;
                var hopexProviderVisible = hopexProviderEnabled &&
                    (hopexProvider == null || !hopexProvider.GetConfiguration<HopexConfig>()?.Hidden == true);

                var otherProviders = providers.Where(x => x.Enabled && x.AuthenticationScheme != "Hopex");

                var noOtherEnabledProviders = !hopexProviderEnabled || otherProviders.Count(ep => ep.Enabled) == 0;

                if (otherProviders.Count() == 1 && (!noOtherEnabledProviders || !hopexProviderVisible))
                {
                    automaticRedirectAfterSignOut = false;
                }
            }

            var client = await _clientStore.FindEnabledClientByIdAsync(logout.ClientId);

            if (client == null)
            {
                throw new Exception($"No client {logout.ClientId} found.");
            }

            var clientName = string.IsNullOrEmpty(client.Description)
                ? (string.IsNullOrEmpty(logout.ClientName) ? logout.ClientId : logout.ClientName)
                : client.Description;

            var postLogoutRedirectUri = string.IsNullOrEmpty(logout.PostLogoutRedirectUri)
                ? _clusterConfiguration.RuntimeClusterSettings.PublicAddress
                : logout.PostLogoutRedirectUri;

            var vm = new LoggedOutViewModel
            {
                AutomaticRedirectAfterSignOut = automaticRedirectAfterSignOut,
                PostLogoutRedirectUri = logout.PostLogoutRedirectUri ?? _clusterConfiguration.RuntimeClusterSettings.PublicAddress,
                ClientName = client.Description ?? (string.IsNullOrEmpty(logout.ClientName) ? logout.ClientId : logout.ClientName),
                SignOutIframeUrl = logout.SignOutIFrameUrl,
                LogoutId = logoutId
            };

            var user = _httpContextAccessor.HttpContext.User;

            if (user?.Identity?.IsAuthenticated == true)
            {
                var idp = _httpContextAccessor.HttpContext.User.FindFirst("idp")?.Value;

                if (idp != null && idp != "local" && await _httpContextAccessor.HttpContext.GetSchemeSupportsSignOutAsync(idp))
                {
                    if (vm.LogoutId == null)
                    {
                        vm.LogoutId = await _interactionService.CreateLogoutContextAsync();
                    }

                    vm.ExternalAuthenticationScheme = idp;
                }
            }

            return vm;
        }

        public async Task<(string error, LoginViewModel viewModel)> BuildLoginViewModelAsync(
            string returnUrl,
            string environmentId,
            bool hideModuleName = false)
        {
            Log.Information("##################################################");
            Log.Information("### BuildLoginViewModelAsync: НАЧАЛО DEBUG v1 ###");
            Log.Information("##################################################");
            Log.Information($"returnUrl = {returnUrl}");
            Log.Information($"environmentId = {environmentId}");
            Log.Information($"hideModuleName = {hideModuleName}");

            string error = string.Empty;

            var providers = _externalProviderService.GetExternalProviders().ToList();
            Log.Information($"Providers count = {providers.Count}");
            foreach (var p in providers)
            {
                Log.Information($"  Provider: {p.AuthenticationScheme}, DisplayName: {p.DisplayName}, Enabled: {p.Enabled}");
            }

            var hopexProvider = providers.FirstOrDefault(x => x.AuthenticationScheme == "Hopex");
            var hopexProviderEnabled = hopexProvider == null || hopexProvider.Enabled;
            var hopexProviderVisible = hopexProviderEnabled &&
                (hopexProvider == null || !hopexProvider.GetConfiguration<HopexConfig>()?.Hidden == true);

            Log.Information($"hopexProvider = {(hopexProvider != null ? "found" : "NULL")}");
            Log.Information($"hopexProviderEnabled = {hopexProviderEnabled}");
            Log.Information($"hopexProviderVisible = {hopexProviderVisible}");

            bool hasNoSsoParam = false;
            try
            {
                var queryParams = HttpUtility.ParseQueryString(HttpUtility.UrlDecode(returnUrl));
                var noSsoValue = queryParams["no_sso"];
                hasNoSsoParam = noSsoValue == "1" ||
                    (noSsoValue?.Equals(bool.TrueString, StringComparison.OrdinalIgnoreCase) == true) ||
                    queryParams.GetValues(null)?.Contains("no_sso") == true;
            }
            catch (Exception)
            {
                // Ignore parsing errors
            }

            var vm = new LoginViewModel
            {
                HopexProviderEnabled = hopexProviderEnabled,
                ShowBasicSignin = false
            };

            var allowLocal = true;
            var isEnvironmentsRequired = false;
            IEnumerable<HopexEnvironmentInfo> environments = null;

            var context = await _interactionService.GetAuthorizationContextAsync(returnUrl);
            Log.Information($"AuthorizationContext = {(context != null ? "OK" : "NULL")}");

            if (context != null)
            {
                Log.Information($"context.Client.ClientId = {context.Client?.ClientId}");
                Log.Information($"context.IdP = {context.IdP}");
                
                if (!string.IsNullOrEmpty(context.IdP) && !context.IdP.Equals("local"))
                {
                    allowLocal = false;
                    providers = providers.Where(provider => provider.AuthenticationScheme == context.IdP).ToList();
                }

                if (!hideModuleName)
                {
                    vm.ModuleFriendlyName = await ModuleHelper.GetModuleFriendlyName(_clusterAdminClient, returnUrl);
                }

                if (hopexProviderEnabled)
                {
                    Log.Information("##################################################");
                    Log.Information("### ВЫЗОВ _hopexSSPClient.GetEnvironments() ###");
                    Log.Information("##################################################");
                    
                    // Логируем информацию о HTTP контексте
                    try
                    {
                        var httpContext = _httpContextAccessor.HttpContext;
                        if (httpContext != null)
                        {
                            Log.Information($"HttpContext.Request.Scheme: {httpContext.Request.Scheme}");
                            Log.Information($"HttpContext.Request.Host: {httpContext.Request.Host}");
                            Log.Information($"HttpContext.Request.Path: {httpContext.Request.Path}");
                            Log.Information($"HttpContext.Request.PathBase: {httpContext.Request.PathBase}");
                            
                            // Логируем заголовки запроса
                            Log.Information("Request Headers:");
                            foreach (var header in httpContext.Request.Headers)
                            {
                                if (!header.Key.ToLower().Contains("cookie") && !header.Key.ToLower().Contains("auth"))
                                {
                                    Log.Information($"  {header.Key}: {header.Value}");
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Warning($"Ошибка при логировании HttpContext: {ex.Message}");
                    }

                    try
                    {
                        Log.Information(">>> Вызываем GetEnvironments()...");
                        var stopwatch = System.Diagnostics.Stopwatch.StartNew();
                        
                        environments = await _hopexSSPClient.GetEnvironments();
                        
                        stopwatch.Stop();
                        Log.Information($"<<< GetEnvironments() УСПЕХ за {stopwatch.ElapsedMilliseconds} мс");
                        Log.Information($"environments count = {environments?.Count() ?? 0}");
                        
                        if (environments != null)
                        {
                            foreach (var env in environments)
                            {
                                Log.Information($"  Environment: Id={env.Id}, Name={env.Name}");
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Error("##################################################");
                        Log.Error("### EXCEPTION при GetEnvironments() ###");
                        Log.Error("##################################################");
                        
                        // Полная информация об исключении
                        LogExceptionDetails(ex, 0);
                        
                        _logger.LogError(ex, "Unable to retrieve environments");
                        error = "Unable to retrieve environments.";
                    }
                }

                if (context.Client?.ClientId != null)
                {
                    var client = await _clientStore.FindEnabledClientByIdAsync(context.Client.ClientId);

                    if (client != null)
                    {
                        allowLocal = client.EnableLocalLogin;

                        if (client.IdentityProviderRestrictions?.Any() == true)
                        {
                            providers = providers.Where(provider =>
                                client.IdentityProviderRestrictions.Contains(provider.AuthenticationScheme)).ToList();
                        }
                    }
                }

                var windowsProvider = providers.FirstOrDefault(c => c.AuthenticationScheme == "Windows");

                if (windowsProvider != null)
                {
                    var windowsConfig = windowsProvider.GetConfiguration<WindowsConfig>();
                    AccountOptions.IncludeWindowsGroups = true;
                    AccountOptions.WindowsGroupsAuthorized = windowsConfig.WindowsRole;
                    AccountOptions.WindowsSourceIdentifier = windowsConfig.WindowsSourceIdentifier;
                    AccountOptions.ClaimForRoles = windowsConfig.ClaimForRoles;
                }
            }

            vm.IsEnvironmentsRequired = isEnvironmentsRequired;
            vm.EnvironmentId = environmentId;
            vm.AllowRememberLogin = AccountOptions.AllowRememberLogin;
            vm.IsSetupMode = !_clusterConfiguration.IsInitialized;
            vm.ReturnUrl = returnUrl;
            vm.Environments = environments?.Select(e => new SelectListItem(e.Name, e.Id));
            vm.UserName = context?.LoginHint;
            vm.ExternalProviders = providers?.ToArray() ?? Enumerable.Empty<ExternalProvider>();
            vm.ShowBasicSignin |= allowLocal && AccountOptions.AllowLocalLogin &&
                vm.HopexProviderEnabled && (hopexProviderVisible || hasNoSsoParam);

            Log.Information($"РЕЗУЛЬТАТ: vm.Environments = {(vm.Environments != null ? $"OK ({vm.Environments.Count()} items)" : "NULL")}");
            Log.Information($"РЕЗУЛЬТАТ: error = '{error}'");
            Log.Information("### BuildLoginViewModelAsync: КОНЕЦ ###");

            return (error, vm);
        }

        /// <summary>
        /// Рекурсивное логирование всех деталей исключения
        /// </summary>
        private void LogExceptionDetails(Exception ex, int level)
        {
            var prefix = new string(' ', level * 2);
            var levelName = level == 0 ? "EXCEPTION" : $"INNER[{level}]";
            
            Log.Error($"{prefix}=== {levelName} ===");
            Log.Error($"{prefix}Type: {ex.GetType().FullName}");
            Log.Error($"{prefix}Message: {ex.Message}");
            Log.Error($"{prefix}Source: {ex.Source}");
            
            // Логируем все публичные свойства исключения
            try
            {
                var exType = ex.GetType();
                foreach (var prop in exType.GetProperties())
                {
                    try
                    {
                        // Пропускаем стандартные свойства которые уже залогировали
                        if (prop.Name == "Message" || prop.Name == "Source" || prop.Name == "StackTrace" || 
                            prop.Name == "InnerException" || prop.Name == "TargetSite" || prop.Name == "Data" ||
                            prop.Name == "HelpLink" || prop.Name == "HResult")
                            continue;
                            
                        var value = prop.GetValue(ex);
                        if (value != null)
                        {
                            Log.Error($"{prefix}{prop.Name}: {value}");
                        }
                    }
                    catch { }
                }
            }
            catch { }
            
            // Для HttpException и похожих - пробуем получить StatusCode
            try
            {
                var statusCodeProp = ex.GetType().GetProperty("StatusCode");
                if (statusCodeProp != null)
                {
                    var statusCode = statusCodeProp.GetValue(ex);
                    Log.Error($"{prefix}StatusCode: {statusCode}");
                }
            }
            catch { }
            
            // Для WebException - пробуем получить Response
            if (ex is System.Net.WebException webEx)
            {
                try
                {
                    Log.Error($"{prefix}WebException.Status: {webEx.Status}");
                    if (webEx.Response != null)
                    {
                        var response = webEx.Response as System.Net.HttpWebResponse;
                        if (response != null)
                        {
                            Log.Error($"{prefix}Response.StatusCode: {response.StatusCode}");
                            Log.Error($"{prefix}Response.StatusDescription: {response.StatusDescription}");
                            Log.Error($"{prefix}Response.ResponseUri: {response.ResponseUri}");
                        }
                    }
                }
                catch { }
            }
            
            // Для HttpRequestException
            if (ex is System.Net.Http.HttpRequestException httpReqEx)
            {
                Log.Error($"{prefix}HttpRequestException.StatusCode: {httpReqEx.StatusCode}");
            }
            
            // Логируем Data dictionary
            if (ex.Data != null && ex.Data.Count > 0)
            {
                Log.Error($"{prefix}Data:");
                foreach (var key in ex.Data.Keys)
                {
                    Log.Error($"{prefix}  [{key}]: {ex.Data[key]}");
                }
            }
            
            Log.Error($"{prefix}StackTrace:");
            if (!string.IsNullOrEmpty(ex.StackTrace))
            {
                foreach (var line in ex.StackTrace.Split('\n').Take(15))
                {
                    Log.Error($"{prefix}  {line.Trim()}");
                }
            }
            
            // Рекурсивно логируем внутренние исключения
            if (ex.InnerException != null)
            {
                LogExceptionDetails(ex.InnerException, level + 1);
            }
            
            // Для AggregateException логируем все внутренние исключения
            if (ex is AggregateException aggEx)
            {
                int i = 0;
                foreach (var inner in aggEx.InnerExceptions)
                {
                    Log.Error($"{prefix}=== AggregateException.InnerExceptions[{i}] ===");
                    LogExceptionDetails(inner, level + 1);
                    i++;
                }
            }
        }

        public async Task<LostPasswordViewModel> BuildLostPasswordViewModel()
        {
            var vm = new LostPasswordViewModel();

            try
            {
                var environments = await _hopexSSPClient.GetEnvironments();

                if (environments == null || !environments.Any())
                {
                    vm.Environments = null;
                }
                else
                {
                    vm.Environments = environments.Select(e => new SelectListItem(e.Name, e.Id));
                }
            }
            catch (Exception ex)
            {
                Log.Error($"BuildLostPasswordViewModel: Ошибка GetEnvironments: {ex.Message}");
                vm.Environments = null;
            }

            return vm;
        }

        public async Task<MappingViewModel> BuildMappingViewModelAsync(
            string environmentId,
            string userName,
            string returnUrl,
            string provider,
            string claimForRoles,
            IEnumerable<Claim> claims)
        {
            GetPersonGroupsResult personGroupsResult = null;

            var queryParams = HttpUtility.ParseQueryString(HttpUtility.UrlDecode(returnUrl));

            var vm = new MappingViewModel
            {
                PersonGroups = personGroupsResult,
                EnvironmentId = environmentId,
                ReturnUrl = returnUrl,
                UserName = userName,
                RepositoryId = queryParams.Get("Db") ?? claims.FirstOrDefault(c => c.Type == "has.repositoryid")?.Value,
                ProfileId = queryParams.Get("Profile") ?? claims.FirstOrDefault(c => c.Type == "has.profileId")?.Value,
                UserId = claims.FirstOrDefault(c => c.Type == "has.userId")?.Value,
                AssignableElementId = claims.FirstOrDefault(c => c.Type == "has.assignableElementId")?.Value,
                DataLanguageId = claims.FirstOrDefault(c => c.Type == "has.dataLanguageId")?.Value,
                GuiLanguageId = claims.FirstOrDefault(c => c.Type == "has.guiLanguageId")?.Value,
                Login = claims.FirstOrDefault(c => c.Type == "has.login")?.Value,
                Provider = provider,
                ClaimForRoles = claimForRoles
            };

            var environments = await _hopexSSPClient.GetEnvironments();
            vm.Environments = environments.Select(e => new SelectListItem(e.Name, e.Id));
            vm.ModuleFriendlyName = await ModuleHelper.GetModuleFriendlyName(_clusterAdminClient, returnUrl);

            if (vm.EnvironmentId == null && vm.Environments.Count() == 1)
            {
                vm.EnvironmentId = vm.Environments.First().Value;
            }

            try
            {
                personGroupsResult = await _hopexSSPClient.GetPersonGroups(new GetPersonGroupsArgs
                {
                    EnvironmentId = vm.EnvironmentId,
                    UserName = userName,
                    Provider = provider,
                    Db = vm.RepositoryId,
                    Profile = vm.ProfileId,
                    ClaimForRoles = claimForRoles
                }, claims);
            }
            catch (Exception)
            {
                vm.ErrorMessage = "Login is not possible.<br/>Please contact your HOPEX administrator to check logs.";
            }

            vm.PersonGroups = personGroupsResult;

            _logger.LogInformation($"Claims and Roles From Provider [ {claims.SerializeToString()} ]");

            if (_httpContextAccessor.HttpContext.Request.Path.HasValue &&
                _httpContextAccessor.HttpContext.Request.Path.Value.Contains("MappingSubmit"))
            {
                throw new NoProfileException(string.Format(
                    S["No profile is configured for the user {0}. Please contact your administrator."],
                    vm.UserName));
            }

            return vm;
        }
    }
}
