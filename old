using dnlib.DotNet;
using dnlib.DotNet.Emit;

if (args.Length == 0)
{
    Console.WriteLine("Использование: ILExtractor <сборка.dll> [папка_вывода]");
    return;
}

var assemblyPath = args[0];
var outputDir = args.Length > 1 ? args[1] : "IL_Output";

var module = ModuleDefMD.Load(assemblyPath);

foreach (var type in module.GetTypes())
{
    if (type.Name == "<Module>") continue;
    
    // Создаём путь по namespace
    var ns = string.IsNullOrEmpty(type.Namespace) ? "_Global" : type.Namespace.ToString().Replace('.', Path.DirectorySeparatorChar);
    var nsPath = Path.Combine(outputDir, ns);
    
    Directory.CreateDirectory(nsPath);
    
    var typeName = SanitizeName(type.Name);
    var filePath = Path.Combine(nsPath, $"{typeName}.il");
    
    using var writer = new StreamWriter(filePath);
    
    foreach (var method in type.Methods)
    {
        if (!method.HasBody) continue;
        
        // Заголовок метода
        writer.WriteLine($"//{method.Name}");
        writer.WriteLine($"// {method.FullName}");
        writer.WriteLine();
        
        foreach (var instr in method.Body.Instructions)
        {
            var operand = FormatOperand(instr);
            writer.WriteLine($"IL_{instr.Offset:X4}: {instr.OpCode.Name,-12} {operand}");
        }
        
        writer.WriteLine();
        writer.WriteLine();
    }
    
    Console.WriteLine($"Обработан: {type.FullName}");
}

Console.WriteLine($"\nГотово: {outputDir}");

string SanitizeName(string name)
{
    var invalid = Path.GetInvalidFileNameChars();
    foreach (var c in invalid)
        name = name.Replace(c, '_');
    
    name = name.Replace('<', '_').Replace('>', '_').Replace('`', '_');
    
    return name;
}

string FormatOperand(Instruction instr)
{
    if (instr.Operand == null) return "";
    
    return instr.Operand switch
    {
        Instruction target => $"IL_{target.Offset:X4}",
        Instruction[] targets => string.Join(", ", targets.Select(t => $"IL_{t.Offset:X4}")),
        string s => $"\"{s.Replace("\"", "\\\"").Replace("\n", "\\n").Replace("\r", "\\r")}\"",
        IField f => f.FullName,
        IMethod m => m.FullName,
        ITypeDefOrRef t => t.FullName,
        Local l => $"V_{l.Index}",
        Parameter p => $"A_{p.Index}",
        _ => instr.Operand.ToString() ?? ""
    };
}
```

**Структура теперь:**
```
IL_Output/
├── MyNamespace/
│   ├── MyClass.il          ← все методы класса внутри
│   └── AnotherClass.il
└── _Global/
    └── SomeClass.il
```

**Содержимое файла класса:**
```
// ===== .ctor =====
// System.Void MyNamespace.MyClass::.ctor()

IL_0000: ldarg.0
IL_0001: call         System.Void System.Object::.ctor()
IL_0006: ret


// ===== DoSomething =====
// System.String MyNamespace.MyClass::DoSomething(System.Int32)

IL_0000: ldarg.1
IL_0001: box          System.Int32
IL_0006: ret
