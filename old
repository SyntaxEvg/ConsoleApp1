using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Text;

if (args.Length == 0)
{
    Console.WriteLine("Использование: ILExtractor <сборка.dll> [папка_вывода]");
    return;
}

var assemblyPath = args[0];
var outputDir = args.Length > 1 ? args[1] : "IL_Output";

var module = ModuleDefMD.Load(assemblyPath);

Directory.CreateDirectory(outputDir);

// Защита от бесконечных циклов
var processedTypes = new HashSet<TypeDef>();
var typeStack = new HashSet<TypeDef>(); // Для обнаружения циклов в текущем пути

const int MAX_DEPTH = 50; // Максимальная глубина рекурсии
const int MAX_GENERIC_DEPTH = 20; // Для generic типов

SaveAssemblyInfo(module, outputDir);
ProcessTypes(module.Types, outputDir, 0);

Console.WriteLine($"\nГотово: {outputDir}");

// ==================== РЕКУРСИВНАЯ ОБРАБОТКА ТИПОВ ====================

void ProcessTypes(IEnumerable<TypeDef> types, string currentPath, int depth)
{
    if (depth > MAX_DEPTH)
    {
        Console.WriteLine($"ПРЕДУПРЕЖДЕНИЕ: Достигнута максимальная глубина вложенности ({MAX_DEPTH})");
        return;
    }
    
    foreach (var type in types)
    {
        if (type.Name == "<Module>") continue;
        
        // Защита от повторной обработки
        if (processedTypes.Contains(type))
        {
            Console.WriteLine($"Пропущен (уже обработан): {type.FullName}");
            continue;
        }
        
        // Защита от циклических ссылок
        if (typeStack.Contains(type))
        {
            Console.WriteLine($"ПРЕДУПРЕЖДЕНИЕ: Обнаружена циклическая ссылка: {type.FullName}");
            continue;
        }
        
        processedTypes.Add(type);
        typeStack.Add(type);
        
        try
        {
            string typePath;
            if (type.IsNested)
            {
                typePath = currentPath;
            }
            else
            {
                var ns = string.IsNullOrEmpty(type.Namespace) 
                    ? "_Global" 
                    : type.Namespace.ToString().Replace('.', Path.DirectorySeparatorChar);
                typePath = Path.Combine(outputDir, ns);
            }
            
            Directory.CreateDirectory(typePath);
            
            var typeName = SanitizeName(type.Name);
            var filePath = Path.Combine(typePath, $"{typeName}.il");
            
            using var writer = new StreamWriter(filePath, false, Encoding.UTF8);
            WriteType(writer, type, 0);
            
            Console.WriteLine($"Обработан: {type.FullName}");
            
            // Рекурсивно обрабатываем вложенные типы
            if (type.HasNestedTypes)
            {
                var nestedPath = Path.Combine(typePath, typeName + "_Nested");
                Directory.CreateDirectory(nestedPath);
                ProcessTypes(type.NestedTypes, nestedPath, depth + 1);
            }
        }
        finally
        {
            typeStack.Remove(type);
        }
    }
}

// ==================== ASSEMBLY INFO ====================

void SaveAssemblyInfo(ModuleDefMD mod, string outDir)
{
    var sb = new StringBuilder();
    
    sb.AppendLine("// ==============================================================");
    sb.AppendLine("// ASSEMBLY MANIFEST");
    sb.AppendLine("// ==============================================================");
    sb.AppendLine();
    
    if (mod.Assembly != null)
    {
        sb.AppendLine($".assembly {mod.Assembly.Name}");
        sb.AppendLine("{");
        sb.AppendLine($"    .ver {mod.Assembly.Version.Major}:{mod.Assembly.Version.Minor}:{mod.Assembly.Version.Build}:{mod.Assembly.Version.Revision}");
        
        if (mod.Assembly.PublicKey != null && mod.Assembly.PublicKey.Data.Length > 0)
            sb.AppendLine($"    .publickey = ({BitConverter.ToString(mod.Assembly.PublicKey.Data).Replace("-", " ")})");
        
        if (!string.IsNullOrEmpty(mod.Assembly.Culture))
            sb.AppendLine($"    .culture \"{mod.Assembly.Culture}\"");
        
        foreach (var attr in mod.Assembly.CustomAttributes)
        {
            sb.AppendLine($"    .custom {FormatCustomAttribute(attr)}");
        }
        
        sb.AppendLine("}");
    }
    
    sb.AppendLine();
    sb.AppendLine($".module {mod.Name}");
    sb.AppendLine($"// MVID: {{{mod.Mvid}}}");
    sb.AppendLine($"// Runtime: {mod.RuntimeVersion}");
    sb.AppendLine($"// Kind: {mod.Kind}");
    sb.AppendLine();
    
    sb.AppendLine("// ==============================================================");
    sb.AppendLine("// ASSEMBLY REFERENCES");
    sb.AppendLine("// ==============================================================");
    sb.AppendLine();
    
    foreach (var asmRef in mod.GetAssemblyRefs())
    {
        sb.AppendLine($".assembly extern {asmRef.Name}");
        sb.AppendLine("{");
        sb.AppendLine($"    .ver {asmRef.Version.Major}:{asmRef.Version.Minor}:{asmRef.Version.Build}:{asmRef.Version.Revision}");
        
        if (asmRef.PublicKeyOrToken != null && asmRef.PublicKeyOrToken.Data.Length > 0)
            sb.AppendLine($"    .publickeytoken = ({BitConverter.ToString(asmRef.PublicKeyOrToken.Data).Replace("-", " ")})");
        
        sb.AppendLine("}");
        sb.AppendLine();
    }
    
    foreach (var modRef in mod.GetModuleRefs())
    {
        sb.AppendLine($".module extern {modRef.Name}");
    }
    
    File.WriteAllText(Path.Combine(outDir, "_AssemblyManifest.il"), sb.ToString());
}

// ==================== TYPE ====================

void WriteType(StreamWriter writer, TypeDef type, int depth)
{
    if (depth > MAX_DEPTH)
    {
        writer.WriteLine($"// ПРЕДУПРЕЖДЕНИЕ: Превышена максимальная глубина ({MAX_DEPTH})");
        return;
    }
    
    var indent = new string(' ', depth * 4);
    
    writer.WriteLine($"{indent}// ==============================================================");
    writer.WriteLine($"{indent}// TYPE: {type.FullName}");
    writer.WriteLine($"{indent}// Token: 0x{type.MDToken.Raw:X8}");
    writer.WriteLine($"{indent}// ==============================================================");
    writer.WriteLine();
    
    writer.Write($"{indent}.class ");
    
    if (type.IsNested)
    {
        if (type.IsNestedPublic) writer.Write("nested public ");
        else if (type.IsNestedPrivate) writer.Write("nested private ");
        else if (type.IsNestedFamily) writer.Write("nested family ");
        else if (type.IsNestedAssembly) writer.Write("nested assembly ");
        else if (type.IsNestedFamORAssem) writer.Write("nested famorassem ");
        else if (type.IsNestedFamANDAssem) writer.Write("nested famandassem ");
    }
    else
    {
        if (type.IsPublic) writer.Write("public ");
        else writer.Write("private ");
    }
    
    if (type.IsInterface) writer.Write("interface ");
    if (type.IsAbstract) writer.Write("abstract ");
    if (type.IsSealed) writer.Write("sealed ");
    if (type.IsAutoLayout) writer.Write("auto ");
    if (type.IsSequentialLayout) writer.Write("sequential ");
    if (type.IsExplicitLayout) writer.Write("explicit ");
    if (type.IsAnsiClass) writer.Write("ansi ");
    if (type.IsUnicodeClass) writer.Write("unicode ");
    if (type.IsBeforeFieldInit) writer.Write("beforefieldinit ");
    if (type.IsSerializable) writer.Write("serializable ");
    if (type.IsSpecialName) writer.Write("specialname ");
    if (type.IsRuntimeSpecialName) writer.Write("rtspecialname ");
    
    writer.Write(type.Name);
    
    if (type.HasGenericParameters)
    {
        writer.Write("<");
        for (int i = 0; i < type.GenericParameters.Count; i++)
        {
            if (i > 0) writer.Write(", ");
            var gp = type.GenericParameters[i];
            WriteGenericParamConstraints(writer, gp);
            writer.Write(gp.Name);
        }
        writer.Write(">");
    }
    
    writer.WriteLine();
    
    if (type.BaseType != null)
    {
        writer.WriteLine($"{indent}    extends {FormatTypeRef(type.BaseType, 0)}");
    }
    
    if (type.HasInterfaces)
    {
        writer.WriteLine($"{indent}    implements");
        for (int i = 0; i < type.Interfaces.Count; i++)
        {
            var comma = i < type.Interfaces.Count - 1 ? "," : "";
            writer.WriteLine($"{indent}        {FormatTypeRef(type.Interfaces[i].Interface, 0)}{comma}");
        }
    }
    
    writer.WriteLine($"{indent}{{");
    
    foreach (var attr in type.CustomAttributes)
    {
        writer.WriteLine($"{indent}    .custom {FormatCustomAttribute(attr)}");
    }
    
    if (type.HasCustomAttributes)
        writer.WriteLine();
    
    if (type.ClassLayout != null)
    {
        writer.WriteLine($"{indent}    .pack {type.ClassLayout.PackingSize}");
        writer.WriteLine($"{indent}    .size {type.ClassLayout.ClassSize}");
        writer.WriteLine();
    }
    
    if (type.HasFields)
    {
        writer.WriteLine($"{indent}    // ==== FIELDS ====");
        writer.WriteLine();
        foreach (var field in type.Fields)
        {
            WriteField(writer, field, depth + 1);
        }
        writer.WriteLine();
    }
    
    if (type.HasProperties)
    {
        writer.WriteLine($"{indent}    // ==== PROPERTIES ====");
        writer.WriteLine();
        foreach (var prop in type.Properties)
        {
            WriteProperty(writer, prop, depth + 1);
        }
        writer.WriteLine();
    }
    
    if (type.HasEvents)
    {
        writer.WriteLine($"{indent}    // ==== EVENTS ====");
        writer.WriteLine();
        foreach (var evt in type.Events)
        {
            WriteEvent(writer, evt, depth + 1);
        }
        writer.WriteLine();
    }
    
    if (type.HasMethods)
    {
        writer.WriteLine($"{indent}    // ==== METHODS ====");
        writer.WriteLine();
        foreach (var method in type.Methods)
        {
            WriteMethod(writer, method, depth + 1);
        }
    }
    
    if (type.HasNestedTypes)
    {
        writer.WriteLine($"{indent}    // ==== NESTED TYPES ====");
        writer.WriteLine();
        foreach (var nested in type.NestedTypes)
        {
            // Проверка на циклическую ссылку
            if (typeStack.Contains(nested))
            {
                writer.WriteLine($"{indent}    // ЦИКЛ: {nested.FullName} (см. отдельный файл)");
                continue;
            }
            
            WriteType(writer, nested, depth + 1);
            writer.WriteLine();
        }
    }
    
    writer.WriteLine($"{indent}}} // end of class {type.Name}");
}

// ==================== FIELD ====================

void WriteField(StreamWriter writer, FieldDef field, int depth)
{
    var indent = new string(' ', depth * 4);
    
    writer.Write($"{indent}.field ");
    
    if (field.IsPublic) writer.Write("public ");
    else if (field.IsPrivate) writer.Write("private ");
    else if (field.IsFamily) writer.Write("family ");
    else if (field.IsAssembly) writer.Write("assembly ");
    else if (field.IsFamilyOrAssembly) writer.Write("famorassem ");
    else if (field.IsFamilyAndAssembly) writer.Write("famandassem ");
    
    if (field.IsStatic) writer.Write("static ");
    if (field.IsInitOnly) writer.Write("initonly ");
    if (field.IsLiteral) writer.Write("literal ");
    if (field.IsNotSerialized) writer.Write("notserialized ");
    if (field.IsSpecialName) writer.Write("specialname ");
    if (field.IsRuntimeSpecialName) writer.Write("rtspecialname ");
    
    if (field.FieldOffset.HasValue)
    {
        writer.Write($"[{field.FieldOffset.Value}] ");
    }
    
    writer.Write($"{FormatTypeSig(field.FieldType, 0)} {field.Name}");
    
    if (field.HasConstant)
    {
        writer.Write($" = {FormatConstant(field.Constant.Value, field.FieldType)}");
    }
    
    if (field.HasFieldRVA)
    {
        writer.Write($" at D_{field.RVA:X8}");
    }
    
    writer.WriteLine();
    
    foreach (var attr in field.CustomAttributes)
    {
        writer.WriteLine($"{indent}    .custom {FormatCustomAttribute(attr)}");
    }
}

// ==================== PROPERTY ====================

void WriteProperty(StreamWriter writer, PropertyDef prop, int depth)
{
    var indent = new string(' ', depth * 4);
    
    writer.Write($"{indent}.property ");
    
    if (prop.IsSpecialName) writer.Write("specialname ");
    if (prop.IsRuntimeSpecialName) writer.Write("rtspecialname ");
    
    var propSig = prop.PropertySig;
    if (propSig != null && propSig.HasThis)
        writer.Write("instance ");
    
    writer.WriteLine($"{FormatTypeSig(propSig?.RetType, 0)} {prop.Name}()");
    writer.WriteLine($"{indent}{{");
    
    foreach (var attr in prop.CustomAttributes)
    {
        writer.WriteLine($"{indent}    .custom {FormatCustomAttribute(attr)}");
    }
    
    if (prop.GetMethod != null)
        writer.WriteLine($"{indent}    .get {FormatMethodRef(prop.GetMethod, 0)}");
    
    if (prop.SetMethod != null)
        writer.WriteLine($"{indent}    .set {FormatMethodRef(prop.SetMethod, 0)}");
    
    foreach (var other in prop.OtherMethods)
    {
        writer.WriteLine($"{indent}    .other {FormatMethodRef(other, 0)}");
    }
    
    writer.WriteLine($"{indent}}}");
}

// ==================== EVENT ====================

void WriteEvent(StreamWriter writer, EventDef evt, int depth)
{
    var indent = new string(' ', depth * 4);
    
    writer.Write($"{indent}.event ");
    
    if (evt.IsSpecialName) writer.Write("specialname ");
    if (evt.IsRuntimeSpecialName) writer.Write("rtspecialname ");
    
    writer.WriteLine($"{FormatTypeRef(evt.EventType, 0)} {evt.Name}");
    writer.WriteLine($"{indent}{{");
    
    foreach (var attr in evt.CustomAttributes)
    {
        writer.WriteLine($"{indent}    .custom {FormatCustomAttribute(attr)}");
    }
    
    if (evt.AddMethod != null)
        writer.WriteLine($"{indent}    .addon {FormatMethodRef(evt.AddMethod, 0)}");
    
    if (evt.RemoveMethod != null)
        writer.WriteLine($"{indent}    .removeon {FormatMethodRef(evt.RemoveMethod, 0)}");
    
    if (evt.InvokeMethod != null)
        writer.WriteLine($"{indent}    .fire {FormatMethodRef(evt.InvokeMethod, 0)}");
    
    foreach (var other in evt.OtherMethods)
    {
        writer.WriteLine($"{indent}    .other {FormatMethodRef(other, 0)}");
    }
    
    writer.WriteLine($"{indent}}}");
}

// ==================== METHOD ====================

void WriteMethod(StreamWriter writer, MethodDef method, int depth)
{
    var indent = new string(' ', depth * 4);
    
    writer.WriteLine($"{indent}// Token: 0x{method.MDToken.Raw:X8}");
    writer.WriteLine($"{indent}// RVA: 0x{method.RVA:X8}");
    writer.Write($"{indent}.method ");
    
    if (method.IsPublic) writer.Write("public ");
    else if (method.IsPrivate) writer.Write("private ");
    else if (method.IsFamily) writer.Write("family ");
    else if (method.IsAssembly) writer.Write("assembly ");
    else if (method.IsFamilyOrAssembly) writer.Write("famorassem ");
    else if (method.IsFamilyAndAssembly) writer.Write("famandassem ");
    
    if (method.IsStatic) writer.Write("static ");
    if (method.IsFinal) writer.Write("final ");
    if (method.IsVirtual) writer.Write("virtual ");
    if (method.IsAbstract) writer.Write("abstract ");
    if (method.IsHideBySig) writer.Write("hidebysig ");
    if (method.IsNewSlot) writer.Write("newslot ");
    if (method.IsSpecialName) writer.Write("specialname ");
    if (method.IsRuntimeSpecialName) writer.Write("rtspecialname ");
    if (method.IsPinvokeImpl) writer.Write("pinvokeimpl ");
    if (method.IsUnmanagedExport) writer.Write("unmanagedexp ");
    
    var sig = method.MethodSig;
    if (sig != null)
    {
        if (sig.HasThis) writer.Write("instance ");
        if (sig.ExplicitThis) writer.Write("explicit ");
        
        switch (sig.CallingConvention & CallingConvention.Mask)
        {
            case CallingConvention.VarArg: writer.Write("vararg "); break;
            case CallingConvention.NativeVarArg: writer.Write("unmanaged vararg "); break;
        }
    }
    
    writer.WriteLine();
    writer.Write($"{indent}    {FormatTypeSig(method.ReturnType, 0)} ");
    writer.Write(method.Name);
    
    if (method.HasGenericParameters)
    {
        writer.Write("<");
        for (int i = 0; i < method.GenericParameters.Count; i++)
        {
            if (i > 0) writer.Write(", ");
            var gp = method.GenericParameters[i];
            WriteGenericParamConstraints(writer, gp);
            writer.Write(gp.Name);
        }
        writer.Write(">");
    }
    
    writer.Write("(");
    var parameters = method.Parameters.Where(p => !p.IsHiddenThisParameter).ToList();
    for (int i = 0; i < parameters.Count; i++)
    {
        if (i > 0) writer.Write(", ");
        var param = parameters[i];
        
        if (param.ParamDef != null)
        {
            if (param.ParamDef.IsIn) writer.Write("[in] ");
            if (param.ParamDef.IsOut) writer.Write("[out] ");
            if (param.ParamDef.IsOptional) writer.Write("[opt] ");
        }
        
        writer.Write($"{FormatTypeSig(param.Type, 0)} {param.Name}");
    }
    writer.Write(")");
    
    if (method.IsIL) writer.Write(" cil");
    if (method.IsNative) writer.Write(" native");
    if (method.IsRuntime) writer.Write(" runtime");
    if (method.IsManaged) writer.Write(" managed");
    if (method.IsUnmanaged) writer.Write(" unmanaged");
    if (method.IsForwardRef) writer.Write(" forwardref");
    if (method.IsPreserveSig) writer.Write(" preservesig");
    if (method.IsInternalCall) writer.Write(" internalcall");
    if (method.IsSynchronized) writer.Write(" synchronized");
    if (method.NoInlining) writer.Write(" noinlining");
    if (method.NoOptimization) writer.Write(" nooptimization");
    if (method.AggressiveInlining) writer.Write(" aggressiveinlining");
    
    writer.WriteLine();
    writer.WriteLine($"{indent}{{");
    
    foreach (var attr in method.CustomAttributes)
    {
        writer.WriteLine($"{indent}    .custom {FormatCustomAttribute(attr)}");
    }
    
    foreach (var param in method.ParamDefs)
    {
        if (param.HasCustomAttributes || param.HasConstant)
        {
            writer.WriteLine($"{indent}    .param [{param.Sequence}]");
            foreach (var attr in param.CustomAttributes)
            {
                writer.WriteLine($"{indent}        .custom {FormatCustomAttribute(attr)}");
            }
            if (param.HasConstant)
            {
                writer.WriteLine($"{indent}        = {FormatConstant(param.Constant.Value, null)}");
            }
        }
    }
    
    foreach (var ovr in method.Overrides)
    {
        writer.WriteLine($"{indent}    .override {FormatMethodRef(ovr.MethodDeclaration, 0)}");
    }
    
    if (method.HasBody && method.Body != null)
    {
        var body = method.Body;
        
        writer.WriteLine($"{indent}    .maxstack {body.MaxStack}");
        
        if (body.HasVariables)
        {
            writer.Write($"{indent}    .locals ");
            if (body.InitLocals) writer.Write("init ");
            writer.WriteLine("(");
            
            for (int i = 0; i < body.Variables.Count; i++)
            {
                var local = body.Variables[i];
                var comma = i < body.Variables.Count - 1 ? "," : "";
                var name = string.IsNullOrEmpty(local.Name) ? "" : $" {local.Name}";
                writer.WriteLine($"{indent}        [{i}] {FormatTypeSig(local.Type, 0)}{name}{comma}");
            }
            
            writer.WriteLine($"{indent}    )");
        }
        
        if (method == module.EntryPoint)
        {
            writer.WriteLine($"{indent}    .entrypoint");
        }
        
        writer.WriteLine();
        
        foreach (var instr in body.Instructions)
        {
            var label = $"IL_{instr.Offset:X4}";
            var operand = FormatOperand(instr);
            writer.WriteLine($"{indent}    {label}: {instr.OpCode.Name,-12} {operand}");
        }
        
        if (body.HasExceptionHandlers)
        {
            writer.WriteLine();
            foreach (var eh in body.ExceptionHandlers)
            {
                writer.WriteLine($"{indent}    .try IL_{eh.TryStart?.Offset:X4} to IL_{eh.TryEnd?.Offset:X4}");
                
                switch (eh.HandlerType)
                {
                    case ExceptionHandlerType.Catch:
                        writer.WriteLine($"{indent}        catch {FormatTypeRef(eh.CatchType, 0)} handler IL_{eh.HandlerStart?.Offset:X4} to IL_{eh.HandlerEnd?.Offset:X4}");
                        break;
                    case ExceptionHandlerType.Finally:
                        writer.WriteLine($"{indent}        finally handler IL_{eh.HandlerStart?.Offset:X4} to IL_{eh.HandlerEnd?.Offset:X4}");
                        break;
                    case ExceptionHandlerType.Fault:
                        writer.WriteLine($"{indent}        fault handler IL_{eh.HandlerStart?.Offset:X4} to IL_{eh.HandlerEnd?.Offset:X4}");
                        break;
                    case ExceptionHandlerType.Filter:
                        writer.WriteLine($"{indent}        filter IL_{eh.FilterStart?.Offset:X4} handler IL_{eh.HandlerStart?.Offset:X4} to IL_{eh.HandlerEnd?.Offset:X4}");
                        break;
                }
            }
        }
    }
    else
    {
        writer.WriteLine($"{indent}    // No method body");
    }
    
    writer.WriteLine($"{indent}}} // end of method {method.DeclaringType?.Name}::{method.Name}");
    writer.WriteLine();
}

// ==================== GENERIC CONSTRAINTS ====================

void WriteGenericParamConstraints(StreamWriter writer, GenericParam gp)
{
    var constraints = new List<string>();
    
    if (gp.HasReferenceTypeConstraint) constraints.Add("class");
    if (gp.HasNotNullableValueTypeConstraint) constraints.Add("valuetype");
    if (gp.HasDefaultConstructorConstraint) constraints.Add(".ctor");
    
    foreach (var gc in gp.GenericParamConstraints)
    {
        constraints.Add($"({FormatTypeRef(gc.Constraint, 0)})");
    }
    
    if (constraints.Count > 0)
    {
        writer.Write($"({string.Join(", ", constraints)}) ");
    }
}

// ==================== FORMATTING С ЗАЩИТОЙ ОТ БЕСКОНЕЧНОЙ РЕКУРСИИ ====================

string FormatTypeSig(TypeSig? sig, int depth)
{
    if (sig == null) return "void";
    
    if (depth > MAX_GENERIC_DEPTH)
    {
        return $"/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */ {sig.FullName}";
    }
    
    return sig switch
    {
        CorLibTypeSig corLib => corLib.TypeDefOrRef.Name,
        GenericInstSig genInst => FormatGenericInstSig(genInst, depth + 1),
        ByRefSig byRef => $"{FormatTypeSig(byRef.Next, depth + 1)}&",
        PtrSig ptr => $"{FormatTypeSig(ptr.Next, depth + 1)}*",
        SZArraySig szArray => $"{FormatTypeSig(szArray.Next, depth + 1)}[]",
        ArraySig array => FormatArraySig(array, depth + 1),
        GenericVar genVar => $"!{genVar.Number}",
        GenericMVar genMVar => $"!!{genMVar.Number}",
        PinnedSig pinned => $"{FormatTypeSig(pinned.Next, depth + 1)} pinned",
        CModReqdSig modReq => $"{FormatTypeSig(modReq.Next, depth + 1)} modreq({FormatTypeRef(modReq.Modifier, depth + 1)})",
        CModOptSig modOpt => $"{FormatTypeSig(modOpt.Next, depth + 1)} modopt({FormatTypeRef(modOpt.Modifier, depth + 1)})",
        ValueTypeSig valType => $"valuetype {valType.TypeDefOrRef?.FullName ?? "???"}",
        ClassSig classSig => $"class {classSig.TypeDefOrRef?.FullName ?? "???"}",
        FnPtrSig fnPtr => FormatFnPtrSig(fnPtr, depth + 1),
        TypeDefOrRefSig typeDefOrRef => typeDefOrRef.TypeDefOrRef?.FullName ?? "???",
        _ => sig.FullName
    };
}

string FormatGenericInstSig(GenericInstSig genInst, int depth)
{
    if (depth > MAX_GENERIC_DEPTH)
    {
        return $"/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */ {genInst.FullName}";
    }
    
    var sb = new StringBuilder();
    sb.Append(FormatTypeRef(genInst.GenericType?.TypeDefOrRef, depth));
    sb.Append("<");
    
    for (int i = 0; i < genInst.GenericArguments.Count; i++)
    {
        if (i > 0) sb.Append(", ");
        sb.Append(FormatTypeSig(genInst.GenericArguments[i], depth + 1));
    }
    
    sb.Append(">");
    return sb.ToString();
}

string FormatArraySig(ArraySig array, int depth)
{
    if (depth > MAX_GENERIC_DEPTH)
    {
        return $"/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */ {array.FullName}";
    }
    
    var sb = new StringBuilder();
    sb.Append(FormatTypeSig(array.Next, depth + 1));
    sb.Append("[");
    
    for (uint i = 0; i < array.Rank; i++)
    {
        if (i > 0) sb.Append(",");
        
        if (i < (uint)array.LowerBounds.Count || i < (uint)array.Sizes.Count)
        {
            int lower = i < (uint)array.LowerBounds.Count ? array.LowerBounds[(int)i] : 0;
            uint size = i < (uint)array.Sizes.Count ? array.Sizes[(int)i] : 0;
            
            if (lower != 0 || size != 0)
            {
                sb.Append(lower);
                sb.Append("...");
                if (size != 0)
                    sb.Append(lower + (int)size - 1);
            }
        }
    }
    
    sb.Append("]");
    return sb.ToString();
}

string FormatFnPtrSig(FnPtrSig fnPtr, int depth)
{
    if (depth > MAX_GENERIC_DEPTH)
    {
        return "/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */ method ...";
    }
    
    var sb = new StringBuilder();
    sb.Append("method ");
    
    var sig = fnPtr.Signature;
    if (sig.HasThis) sb.Append("instance ");
    
    sb.Append(FormatTypeSig(sig.RetType, depth + 1));
    sb.Append(" *(");
    
    for (int i = 0; i < sig.Params.Count; i++)
    {
        if (i > 0) sb.Append(", ");
        sb.Append(FormatTypeSig(sig.Params[i], depth + 1));
    }
    
    sb.Append(")");
    return sb.ToString();
}

string FormatTypeRef(ITypeDefOrRef? type, int depth)
{
    if (type == null) return "???";
    
    if (depth > MAX_GENERIC_DEPTH)
    {
        return $"/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */ {type.FullName}";
    }
    
    if (type is TypeSpec ts && ts.TypeSig != null)
    {
        return FormatTypeSig(ts.TypeSig, depth + 1);
    }
    
    return type.FullName;
}

string FormatMethodRef(IMethod? method, int depth)
{
    if (method == null) return "???";
    
    if (depth > MAX_GENERIC_DEPTH)
    {
        return $"/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */ {method.FullName}";
    }
    
    var sb = new StringBuilder();
    
    if (method.MethodSig?.HasThis == true)
        sb.Append("instance ");
    
    sb.Append($"{FormatTypeSig(method.MethodSig?.RetType, depth + 1)} ");
    sb.Append($"{FormatTypeRef(method.DeclaringType, depth + 1)}::{method.Name}");
    
    if (method is MethodSpec ms && ms.GenericInstMethodSig != null)
    {
        sb.Append("<");
        for (int i = 0; i < ms.GenericInstMethodSig.GenericArguments.Count; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append(FormatTypeSig(ms.GenericInstMethodSig.GenericArguments[i], depth + 1));
        }
        sb.Append(">");
    }
    
    sb.Append("(");
    var paramTypes = method.MethodSig?.Params;
    if (paramTypes != null)
    {
        for (int i = 0; i < paramTypes.Count; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append(FormatTypeSig(paramTypes[i], depth + 1));
        }
    }
    sb.Append(")");
    
    return sb.ToString();
}

string FormatOperand(Instruction instr)
{
    if (instr.Operand == null) return "";
    
    return instr.Operand switch
    {
        Instruction target => $"IL_{target.Offset:X4}",
        Instruction[] targets => "(" + string.Join(", ", targets.Select(t => $"IL_{t.Offset:X4}")) + ")",
        string s => $"\"{EscapeString(s)}\"",
        int i => i.ToString(),
        long l => l.ToString(),
        float f => $"{f:R}",
        double d => $"{d:R}",
        sbyte sb => sb.ToString(),
        byte b => b.ToString(),
        IField field => FormatFieldRef(field),
        IMethod method => FormatMethodRef(method, 0),
        ITypeDefOrRef type => FormatTypeRef(type, 0),
        Local local => $"V_{local.Index}",
        Parameter param => $"A_{param.Index}",
        MethodSig msig => FormatMethodSig(msig),
        _ => instr.Operand.ToString() ?? ""
    };
}

string FormatFieldRef(IField? field)
{
    if (field == null) return "???";
    return $"{FormatTypeSig(field.FieldSig?.Type, 0)} {FormatTypeRef(field.DeclaringType, 0)}::{field.Name}";
}

string FormatMethodSig(MethodSig sig)
{
    var sb = new StringBuilder();
    if (sig.HasThis) sb.Append("instance ");
    sb.Append(FormatTypeSig(sig.RetType, 0));
    sb.Append(" *(");
    
    for (int i = 0; i < sig.Params.Count; i++)
    {
        if (i > 0) sb.Append(", ");
        sb.Append(FormatTypeSig(sig.Params[i], 0));
    }
    
    sb.Append(")");
    return sb.ToString();
}

string FormatCustomAttribute(CustomAttribute attr)
{
    var sb = new StringBuilder();
    sb.Append($"instance void {attr.Constructor?.DeclaringType?.FullName ?? "???"}::.ctor(");
    
    if (attr.Constructor?.MethodSig?.Params != null)
    {
        for (int i = 0; i < attr.Constructor.MethodSig.Params.Count; i++)
        {
            if (i > 0) sb.Append(", ");
            sb.Append(FormatTypeSig(attr.Constructor.MethodSig.Params[i], 0));
        }
    }
    
    sb.Append(")");
    
    if (attr.HasConstructorArguments || attr.HasNamedArguments)
    {
        sb.Append(" = { ");
        
        var parts = new List<string>();
        
        foreach (var arg in attr.ConstructorArguments)
        {
            parts.Add(FormatCAArgument(arg, 0));
        }
        
        foreach (var arg in attr.NamedArguments)
        {
            var prefix = arg.IsField ? "field" : "property";
            parts.Add($"{prefix} {FormatTypeSig(arg.Type, 0)} {arg.Name} = {FormatCAArgument(arg.Argument, 0)}");
        }
        
        sb.Append(string.Join(", ", parts));
        sb.Append(" }");
    }
    
    return sb.ToString();
}

string FormatCAArgument(CAArgument arg, int depth)
{
    if (arg.Value == null) return "nullref";
    
    if (depth > MAX_GENERIC_DEPTH)
    {
        return "/* СЛИШКОМ ГЛУБОКАЯ ВЛОЖЕННОСТЬ */";
    }
    
    return arg.Value switch
    {
        string s => $"\"{EscapeString(s)}\"",
        bool b => b ? "true" : "false",
        UTF8String u => $"\"{EscapeString(u.String)}\"",
        TypeSig t => $"typeof({FormatTypeSig(t, depth + 1)})",
        IList<CAArgument> list => "{" + string.Join(", ", list.Select(a => FormatCAArgument(a, depth + 1))) + "}",
        CAArgument nested => FormatCAArgument(nested, depth + 1),
        _ => arg.Value.ToString() ?? "null"
    };
}

string FormatConstant(object? value, TypeSig? type)
{
    if (value == null) return "nullref";
    
    return value switch
    {
        string s => $"\"{EscapeString(s)}\"",
        char c => $"char(0x{(int)c:X4})",
        bool b => b ? "bool(true)" : "bool(false)",
        float f => $"float32({f:R})",
        double d => $"float64({d:R})",
        sbyte sb => $"int8({sb})",
        byte b => $"uint8({b})",
        short sh => $"int16({sh})",
        ushort us => $"uint16({us})",
        int i => $"int32({i})",
        uint u => $"uint32({u})",
        long l => $"int64({l})",
        ulong ul => $"uint64({ul})",
        byte[] bytes => "(" + BitConverter.ToString(bytes).Replace("-", " ") + ")",
        _ => value.ToString() ?? "null"
    };
}

string EscapeString(string s)
{
    var sb = new StringBuilder();
    foreach (var c in s)
    {
        switch (c)
        {
            case '\\': sb.Append("\\\\"); break;
            case '"': sb.Append("\\\""); break;
            case '\n': sb.Append("\\n"); break;
            case '\r': sb.Append("\\r"); break;
            case '\t': sb.Append("\\t"); break;
            case '\0': sb.Append("\\0"); break;
            default:
                if (c < 32 || c > 126)
                    sb.Append($"\\u{(int)c:X4}");
                else
                    sb.Append(c);
                break;
        }
    }
    return sb.ToString();
}

string SanitizeName(string name)
{
    var invalid = Path.GetInvalidFileNameChars();
    foreach (var c in invalid)
        name = name.Replace(c, '_');
    
    name = name.Replace('<', '_').Replace('>', '_').Replace('`', '_');
    
    return name;
}
