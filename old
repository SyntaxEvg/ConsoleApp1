/* Minification failed. Returning unminified contents.
(4,12-13): run-time error JS1003: Expected ':': (
(4,15-16): run-time error JS1100: Expected ',': {
(8,25-26): run-time error JS1014: Invalid character: `
(8,27-28): run-time error JS1004: Expected ';': {
(8,50-51): run-time error JS1004: Expected ';': {
(8,69-70): run-time error JS1014: Invalid character: `
(9,25-26): run-time error JS1014: Invalid character: `
(9,36-37): run-time error JS1004: Expected ';': $
(9,63-64): run-time error JS1004: Expected ';': {
(9,70-71): run-time error JS1014: Invalid character: `
(13,1-2): run-time error JS1002: Syntax error: }
(14,13-14): run-time error JS1195: Expected expression: )
(14,15-16): run-time error JS1004: Expected ';': {
(25,22-23): run-time error JS1195: Expected expression: .
(26,17-18): run-time error JS1003: Expected ':': (
(26,20-21): run-time error JS1100: Expected ',': {
(34,14-15): run-time error JS1195: Expected expression: ,
(36,14-15): run-time error JS1195: Expected expression: ,
(39,28-29): run-time error JS1004: Expected ';': {
(41,72-73): run-time error JS1195: Expected expression: >
(41,121-122): run-time error JS1004: Expected ';': )
(43,18-19): run-time error JS1195: Expected expression: ,
(46,27-28): run-time error JS1004: Expected ';': {
(48,22-23): run-time error JS1195: Expected expression: ,
(56,18-19): run-time error JS1195: Expected expression: ,
(59,27-28): run-time error JS1004: Expected ';': {
(61,22-23): run-time error JS1195: Expected expression: ,
(67,18-19): run-time error JS1195: Expected expression: ,
(68,13-14): run-time error JS1197: Too many errors. The file might not be a JavaScript file: }
(20,5-35): run-time error JS1301: End of file encountered before function is properly closed: function hotelIndexModel(json)
(68,14-15): run-time error JS1195: Expected expression: ,
(70,13-20): run-time error JS1197: Too many errors. The file might not be a JavaScript file: methods
 */
// свойства простейшей поисковой формы
var hotelSearchFormMixin = {

    mounted() {
        // установить title страницы
        let startForm = $("div[data-start-form]").data("start-form");
        if (startForm) {
            let dates = `${startForm.DateStart}-${startForm.DateEnd}`;
            let title = `Гостиницы ${startForm.LocationName} ${dates}`;
            $(document).attr("title", title);
        }
    }
};
$(function () {
    var vm = Vue.component('hotel-date-picker', HotelDatePicker.default);
    // МОДЕЛЬ СТАРТОВОЙ СТРАНИЦЫ - ПОИСКОВАЯ ФОРМА ОТЕЛЕЙ
    // Используется во вьюхах:
    //          Pages\Search\Hotel\Form\Views\Desktop\Form.cshtml
    //          Pages\Search\Hotel\Form\Views\Mobile\Form.cshtml
    function hotelIndexModel(json) {

        // формируется модель для vue.js
        return {
            el: "#hotel-index",
            mixins: [...window.jv3.utils.mixins.retrieveMixings('hotelIndexModel')],
            data() {
                return {
                    isModelFlipped: false,
                    isModelActive: false,
                    startForm: json, // данные стартовой формы 
                    selectedPlace: { formatted_address: json.LocationName }, // установка координаты выбранной точки для автокомплита
                    dateFormat: "DD.MM.YYYY"
                };
            },
            mounted() {
            },
            computed: {
                // обертка для поля AllTravelPolicies тревел-политик для бинда на селект2
                policies() {
                    if (this.startForm.AllTravelPolicies)
                        return this.startForm.AllTravelPolicies.map(x => ({ id: x.Value, text: x.Key, selected: false }));
                    return [];
                },

                hotelPointCode: {
                    get() {
                        return this.startForm.id_City;
                    },
                    async set(newOrigin) {
                        if (!newOrigin) return;
                        this.startForm.Latitude = null;
                        this.startForm.Longitude = null;
                        this.startForm.id_City = null;
                        this.startForm.id_City = newOrigin.id_City || newOrigin.placeId;
                    }
                },

                hotelPointName: {
                    get() {
                        return this.startForm.LocationName;
                    },
                    set(newOrigin) {
                        if (!newOrigin) return;
                        this.startForm.LocationName = newOrigin;
                        this.startForm.CityName = this.startForm.LocationName;
                    }
                },
            },

            methods: {
                validateDestination() { // валидация пункта назначение - не пустой
                    return !this.startForm.LocationName ? $(".j-destination-col").data("error") : null;
                },
                validateRadius() { // валидация радиуса - больше 0, не пустой
                    return !this.startForm.Radius ? $(".j-radius-col").data("error") : null;
                },
                validateDates() { // валидация дат заезда и выезда
                    if (!this.startForm.DateStart || !this.startForm.DateEnd || this.startForm.DateStart == "Invalid date" || this.startForm.DateEnd == "Invalid date") {
                        return $(".j-wrapper_calendar_input").data("error");
                    }

                    if (moment(this.startForm.DateStart, "DD.MM.YYYY").isBefore(moment(), 'day')
                        || moment(this.startForm.DateEnd, "DD.MM.YYYY").isBefore(moment(), 'day')) { 
                        return $('.j-wrapper_calendar_input').data('datepast-error');
                    }

                    let dateStart = moment(this.startForm.DateStart, this.dateFormat);
                    let dateEnd = moment(this.startForm.DateEnd, this.dateFormat);
                    return dateEnd.diff(dateStart, 'days') < 1 ? $(".j-wrapper_calendar_input").data("error") : null; //return this.startForm.
                },
                validateChildAges() { // валидация возраста детей
                    return this.startForm.ChildAges.length != this.startForm.ChildAges.filter(x => !!x).length || this.startForm.ChildAges.filter(x => x == "").length > 0 ? $(".j-passenger-col").data("error") : null;
                },
                validatePayer() {
                    if (!!this.startForm.AllPayers && !!this.startForm.AllPayers.length && !this.startForm.id_Payer) {
                        return $('#hotel-index').data('validation-payer-error');
                    }
                    return null;
                },
                //задан идентификатор города
                hasCityId() {
                    return !!this.startForm.id_City;
                },

                async startSearchCommon() {
                    // валидация формы
                    var errors = [this.validateDestination(), this.validateRadius(), this.validateChildAges(), this.validateDates(), this.validatePayer()];
                    if (errors.find(x => !!x)) { // есть непустая ошибка 
                        window.jv3.utils.various.error(errors.join("<br/>"));
                    } else {
                        if (this.startForm.id_City && isNaN(Number(this.startForm.id_City))) {
                            // используется автозаполнение от Яндекса, необходимо преобразовать яндексовский ключ места в координаты и обнулить id_City
                            const resp = await axios.get('/HotelSearchForm/ResolveYandexPlaceId/?placeId=' + this.startForm.id_City + '&locationName=' + this.startForm.LocationName);
                            this.startForm.Latitude = resp.data.lat;
                            this.startForm.Longitude = resp.data.lon;
                            this.startForm.id_City = null;
                        }
                        window.dispatchEvent(new CustomEvent('searchStarted',
                            {
                                detail:
                                {
                                    DateStart: this.startForm.DateStart,
                                    DateEnd: this.startForm.DateEnd,
                                    Name: this.startForm.LocationName.split(",")[0]
                                }
                            }));
                        router.next(); // навигация вперед - вызывает метод из файла JavelinView3\Pages\Search\Common\Scripts\searchrouter.js
                    }
                },

            },
        };
    }

    // инициализация контейнера для js-моделей
    if (!window.search)
        window.search = {};
    if (!window.search.hotel)
        window.search.hotel = {
            index: null
        };

    window.search.hotel.index = function () {
        var self = new baseStepModel();

        self.model = null; // модель данных пока пустая - она будет сформирована в методe onLoad

        // данный метод вызывается из базового класса Search\Common\Scripts\base.stepmodel.es6.js
        // в методе load(после загрузки страницы) -  self.onLoad($("div[data-json]").data("json"));
        // таким образом в качестве параметра json придет содерждание атрибута data-json из 
        // Pages\Search\Hotel\Form\Views\Desktop\Form.cshtml - десктоп или
        // Pages\Search\Hotel\Form\Views\Mobile\Form.cshtml - мобильная версия
        self.onLoad = function (json) {
            self.model = new Vue(new hotelIndexModel(json));
            // т.к. координаты могут прийти не совсем точные, например координаты аэропорта в случае апселла, пытаемся уточнить их в гугле
            if (!window.jv3.utils.appSettings.isMobile())
                if (!self.model.hasCityId())
                    if (typeof ymaps !== 'undefined') {
                        const geocoder = ymaps.geocode(self.model.startForm.LocationName);
                        geocoder.then(function (results) { 
                            const place = results.geoObjects.get(0);
                            if (place) {
                                [self.model.startForm.Latitude, self.model.startForm.Longitude] = place.geometry.getCoordinates();
                            }
                        });
                    }
        };

        // вызывается при показе шага
        self.onShow = function () {
            window.dispatchEvent(new CustomEvent('HotelSearchForm.onShow'));
        };

        //Переопределяем шаг выгрузки, очищая бандинги
        self.onUnload = function () {
        };

        return self;
    }();
});;
$(function () {

    // Общие утилиты с глобальной областью видимости
    window.utils = window.utils || {};

    // Вывод на консоль продолжительности
    window.utils.formatDuration = function (milliseconds) {
        if (milliseconds < 1000) {
            return `${milliseconds.toFixed(2)} ms`;
        }
        let seconds = milliseconds / 1000;
        if (seconds < 60) {
            return `${seconds.toFixed(2)} s`;
        }
        let minutes = seconds / 60;
        return `${minutes.toFixed(2)} min`;
    };

    const HTML_ELEMENT_ID = "#hotel-variants"; // на какой элемент биндим модель

    // МОДЕЛЬ ВЫДАЧИ ВАРИАНТОВ РАЗМЕЩЕНИЯ
    // Используется во вьюхах:
    //          Pages\Search\Hotel\Variants\Views\Desktop\Variants.cshtml
    //          Pages\Search\Hotel\Variants\Views\Mobile\Variants.cshtml
    function hotelVariantsModel(initData) {
        Vue.component('virtual-list', VirtualScrollList);
        // формируется модель для vue.js
        var vm = {
            el: HTML_ELEMENT_ID,
            // примеси для расширения модели - https://ru.vuejs.org/v2/guide/mixins.html
            mixins: [hotelSearchFormMixin,
                ...window.jv3.utils.mixins.retrieveMixings('hotel-variants-v2')],
            data() {
                return {
                    frontEnd: {
                        completionPercentage: 0, // процент готовности
                        selectedHotel: {
                            RequestId: initData.requestId,
                            HotelName: null,
                            HasCoordinates: true,
                            Stars: 0,
                            NormalizedName: null,
                            NormalizedNameEn: null,
                            Type: null,
                        },
                        isLoading: true,
                        states: [], // текущие статусы готовности по системам бронирования
                        hotels: [], // список отелей, который выводим в таблице
                        filterFunctions: [],//фильтры применяющиеся к отелям на странице
                        hideSecondaryFilters: false,// скрыть блок доп. фильтров
                        transformerFunctions: [],//функции, преобразовывающие отели на странице
                        sorting: {
                            column: "minimumPrice", // по какой колонке сортируем
                            direction: "ASC", // направление для сортировки
                            sortCache: {}
                        },
                        displayPriceSettings: {
                            isPricePerNight: false,
                            currencies: [
                                {
                                    code: "RUB",
                                    exchRate: 1.0
                                }
                            ],
                            displayCurrency: "RUB"
                        },
                        agenciesDictionary: [],
                        selectedPlace: null,//здесь указано, до какой точки считаентся расстояние от отеля (название, например, Москва, Россия).
                    },
                    initials: initData,
                    modalViolation: {
                        isOpened: false,
                        arrayViolation: null
                    },
                    showFilterPanel: false,
                    sortingFunctionList: [], //список допольнительных функций сортировки; данный контейнер может наполнятся методами сортировки из миксинов (модов)

                    isModelFlipped: false,
                    isModelActive: false,

                    extraFunctionsBeforeGoingToRates: [],
                    executedExtraFunctionsCounter: 0, //счеткик выполеннных действий
                    extraFunctionsOnPushNextPortion: [],//экстра методы при добавлении новой порции отелей

                    serverResponse: {
                        filters: null
                    },
                };
            },
            async mounted() {
                this.frontEnd.selectedPlace = this.initials.startForm.LocationName;
            },
            computed: {
                nights() {
                    return this.initials.startForm.Nights;
                },
                // кросс-курс валюты, в которой отображаем цены
                displayCurrencyRate() {
                    return this.frontEnd.displayPriceSettings.currencies.find(c => c.code === this.frontEnd.displayPriceSettings.displayCurrency).exchRate;
                },
                // список подходящих под фильтры отелей
                hotelsAfterFilters() {
                    let result = this.frontEnd.hotels;
                    if (result.length) {
                        if (this.frontEnd.filterFunctions.length) {
                            let originHotels = this.frontEnd.hotels;
                            for (let item of this.frontEnd.filterFunctions) { // функции фильтрации вариантов
                                result = item.filter(result);
                            }
                            // после фильтрации возможна другая сортировка
                            this.frontEnd.hotels = result;
                            this.sort();
                            result = this.frontEnd.hotels; // REF-898
                            this.frontEnd.hotels = originHotels;
                        }

                        if (this.frontEnd.transformerFunctions.length) {
                            for (let item of this.frontEnd.transformerFunctions) { // функции трансформации вариантов
                                result = item.transform(result);
                            }
                        }
                    }
                    return result;
                },
                //выбранный отель
                selectedVariant() {
                    if (this.frontEnd.selectedHotel.HotelName)
                        return this.frontEnd.hotels.find(h => h.hotelName === this.frontEnd.selectedHotel.HotelName && h.type == this.frontEnd.selectedHotel.Type);
                    return null;
                },
                hasMultiplePaymentTypes() {
                    return this.frontEnd.hotels.filter(f => f.paymentTypes.length > 1).length;
                },
                activeFiltersCount() {
                    return this.frontEnd.filterFunctions.reduce((cnt, item) => item.isActive() ? cnt + 1 : cnt, 0);
                },
                showPreloader() {
                    return (!this.frontEnd.hotels || !this.frontEnd.hotels.length) && this.frontEnd.completionPercentage != 100;
                },
            },
            watch: {
            },
            methods: {
                // выбираем отель получив на вход его имя
                onHotelSelection(hotelName, hasCoordinates, stars, lat, lng, type) {
                    this.setSelectedHotel(hotelName, hasCoordinates, stars, lat, lng, type);
                    this.onHotelSelectionMixin();
                    return false;
                },
                setSelectedHotel(hotelName, hasCoordinates, stars, lat, lng, type) {
                    this.frontEnd.selectedHotel.HotelName = hotelName;
                    this.frontEnd.selectedHotel.HasCoordinates = hasCoordinates;
                    this.frontEnd.selectedHotel.Stars = stars;
                    this.frontEnd.selectedHotel.Latitude = lat;
                    this.frontEnd.selectedHotel.Longitude = lng;
                    this.frontEnd.selectedHotel.Type = type;
                    this.frontEnd.selectedHotel.NormalizedName = this.selectedVariant.normalizedName;
                    this.frontEnd.selectedHotel.NormalizedNameEn = this.selectedVariant.normalizedNameEn;
                },
                //переход на третий шаг
                goNext() {
                    if (this.extraFunctionsBeforeGoingToRates.length > this.executedExtraFunctionsCounter) {
                        this.extraFunctionsBeforeGoingToRates[this.executedExtraFunctionsCounter]();
                        return;
                    }
                    window.router.next();
                },

                // сортирует отели в том или ином направлении по переданноым колонке и направлению - оба параметра не обязательны
                sort(column, direction) {
                    this.baseSort(column, direction);
                    if (this.sortingFunctionList.length)
                        this.customSort(column, direction);
                },

                //сортировка по кастомным фукнциям из модов
                customSort(column, direction) {
                    for (let i = 0; i < this.sortingFunctionList.length; i++) {
                        this.sortingFunctionList[i](column, direction);
                    }
                },

                //основной метод сортировки. 
                baseSort(column, direction) {

                    if (column === this.frontEnd.sorting.column && !direction) {
                        direction = this.frontEnd.sorting.direction === "ASC" ? "DESC" : "ASC";
                    } else if (column) {
                        direction = "ASC";
                    }

                    column = column || this.frontEnd.sorting.column;
                    direction = direction || this.frontEnd.sorting.direction;

                    this.frontEnd.sorting.direction = direction;
                    this.frontEnd.sorting.column = column;

                    const cacheKey = `${column}-${direction}-${this.frontEnd.hotels.length}`;
                    if (this.frontEnd.sorting.sortCache && this.frontEnd.sorting.sortCache[cacheKey]) {
                        this.frontEnd.hotels = [...this.frontEnd.sorting.sortCache[cacheKey]];

                        return;
                    }

                    const isAsc = direction === "ASC";

                    const values = new Map();
                    for (const item of this.frontEnd.hotels) {
                        values.set(item, item[column]);
                    }

                    this.frontEnd.hotels.sort((item1, item2) => {
                        if (item1.isMock) return -1;
                        if (item2.isMock) return 1;

                        const val1 = values.get(item1);
                        const val2 = values.get(item2);

                        if (isAsc) {
                            return val1 < val2 ? -1 : (val1 > val2 ? 1 : 0);
                        } else {
                            return val1 > val2 ? -1 : (val1 < val2 ? 1 : 0);
                        }
                    });

                    this.frontEnd.sorting.sortCache = {};
                    this.frontEnd.sorting.sortCache[cacheKey] = [...this.frontEnd.hotels];

                },

                //// *********************** СБРОС ВСЕХ ФИЛЬТРОВ *******************************
                resetAllFilters() {
                    this.frontEnd.filterFunctions.forEach(item => item.reset());
                },


                // признак того, что в отеле предлагается сервис с указанным кодом, например, pool
                hasService(serviceName, hotel) {
                    return hotel.services.find(s => s === serviceName);
                },
                // отображаемая для пользователя цена с учетом всех настроек фильтров(валюта, за ночь)
                displayPrice(hotel) {
                    if (this.frontEnd.displayPriceSettings.isPricePerNight)
                        return this.displayPriceForNight(hotel);
                    let conversionRate = this.frontEnd.displayPriceSettings.displayCurrency == hotel.currency ? hotel.exchRate : this.displayCurrencyRate;
                    let price = hotel.minimumPrice / conversionRate;
                    return Math.round(price);
                },
                displayPriceForNight(hotel) {
                    let conversionRate = this.frontEnd.displayPriceSettings.displayCurrency == hotel.currency ? hotel.exchRate : this.displayCurrencyRate;
                    let price = hotel.minimumPrice / conversionRate;
                    price /= this.nights;
                    return Math.round(price);
                },
                getRealExchangeRate(hotel) {
                    if (hotel.currency == this.frontEnd.displayPriceSettings.displayCurrency && hotel.exchRate != this.displayCurrencyRate && this.frontEnd.displayPriceSettings.displayCurrency != "RUB")
                        return jv3.utils.various.getCurrencyString(hotel.exchRate, this.initials.currencyLocals.rub, this.initials.currencyLocals.cop);
                    return null;
                },
                // выводит названия поставщиков данного отеля через запятую
                displaySuppliers(hotel) {
                    return hotel.GDS.map(x => this.supplierDecodeById(x)).join();
                },
                // получает название поставщика по его ид
                supplierDecodeById(id_System) {
                    var supplier = this.initials.supplier.filter(f => f.id_System == id_System);
                    if (!supplier || !supplier.length) return "unknown";
                    return supplier[0].name;
                },

                //обработка справочников в порции, эта обработка не тормозит основной поток
                pushPortionDictionaries(portion) {
                    this.serverResponse.filters = portion.filters;
                    this.frontEnd.states = portion.states;

                    if (!!portion.agencyDictionary) {
                        portion.agencyDictionary.forEach(function (agency) {//нужно добавлять агентства в справочник, т.к. в каждой порции может не быть всех возможных агентств
                            if (!this.frontEnd.agenciesDictionary.find(f => f.id === agency.id)) {
                                this.frontEnd.agenciesDictionary.push(agency);
                            }
                        }.bind(this));
                    }

                    for (let i = 0; i < this.frontEnd.hotels.length; i++) {
                        let existedHotel = this.frontEnd.hotels[i];
                        let violationObject = portion.violations.find(f => f.key == existedHotel.key);
                        if (!!violationObject) {
                            existedHotel.violations = violationObject.violations;
                            existedHotel.travelPolicy = violationObject.travelPolicy;
                        }
                    }

                    // кастыль для того, чтобы обновление фильтра по цене не ломало выдачу
                    // https://ru.yougile.com/team/my-tasks#HH-299
                    if (this.serverResponse.filters) {
                        if (this.serverResponse.filters.priceFilter.filterSettings) {

                            portion.filters.priceFilter.filterSettings.minPrice = Math.min(portion.filters.priceFilter.filterSettings.minPrice,
                                                                                            this.serverResponse.filters.priceFilter.filterSettings.minPrice);

                            portion.filters.priceFilter.filterSettings.maxPrice = Math.max(portion.filters.priceFilter.filterSettings.maxPrice,
                                                                                            this.serverResponse.filters.priceFilter.filterSettings.maxPrice);
                        }
                    }

                    this.serverResponse.filters = portion.filters;

                    this.sort();

                    if (!!portion.currencyDictionary) {
                        for (let i = 0; i < portion.currencyDictionary.length; i++) // обновляем список валют
                            if (!this.frontEnd.displayPriceSettings.currencies.find(c => c.code === portion.currencyDictionary[i].currency))
                                this.frontEnd.displayPriceSettings.currencies.push({ code: portion.currencyDictionary[i].currency, exchRate: portion.currencyDictionary[i].cbConversionRate });
                    }

                },

                pushNextPortionResult(result) {
                    this.frontEnd.hotels = result.hotels;
                    this.initials.startForm.Latitude = result.startFormLatitude;
                    this.initials.startForm.Longitude = result.startFormLongitude;
                    this.frontEnd.completionPercentage = result.completionPercentage;
                },


                //общее кол-во отелей
                totalCountHotels() {
                    return this.frontEnd.hotels ? this.frontEnd.hotels.length : 0;
                },

                //сумму в красивую строку, если рубли
                getCurrencyString(sum) {
                    if (this.frontEnd.displayPriceSettings.displayCurrency == "RUB")
                        return jv3.utils.various.getCurrencyString(sum, this.initials.currencyLocals.rub, this.initials.currencyLocals.cop);
                    return `${sum} ${this.frontEnd.displayPriceSettings.displayCurrency}`;
                },
                //для рублей получить общеупотребляемое обозначение
                getCurrencyName(code) {
                    if (code == "RUB")
                        return this.initials.currencyLocals.rub;
                    return code;
                },

                formatDate(val) {
                    return moment(val).format('DD.MM.YYYY');
                },

                //получить инфо агентств, предоставляющих этот отель
                GetAgenciesInfo(hotel) {
                    if (!this.frontEnd.agenciesDictionary || this.frontEnd.agenciesDictionary.length < 2)
                        return null;
                    var info = this.frontEnd.agenciesDictionary.filter(f => hotel.Agencies.includes(f.id));
                    if (!info) return null;

                    return info.map(function (item) {
                        return {
                            name: item.name,
                        };
                    });
                },
                //склонение числительных
                declOfNum(number, titles) {
                    return window.declOfNum(number, titles);
                },
            },
        };
        return vm;
    }

    // инициализация контейнера для js-моделей
    if (!window.search)
        window.search = {};
    if (!window.search.hotel)
        window.search.hotel = {
            variants: {}
        };

    window.search.hotel.variants = function () {
        var self = new baseStepModel();

        self.model = null; // модель данных пока пустая - она будет сформирована в методe onLoad
        self.dataRefresher = null; // таймер, по которому рефрешим данные
        self.ajaxRequestsCounter = 0; // сколько раз мы переопросили сервер
        self.requestId = null; // идентификатор поискового запроса
        self.timestamp = 0; // таймстемп, который передаем на сервер для получения порции

        self.onLoad = function (json) {
            // передаем при первоначальной инициализации данные поисковой формы
            self.model = new Vue(new hotelVariantsModel(json));
            self.ajaxRequestsCounter = 0;
            self.requestId = json.requestId;
            self.timestamp = 0;
            self.getMore(); // добавляем первую порцию отелей в json для первичной инициализации            
        }

        if (!window.search.hotel.variantsWorker) {
            window.search.hotel.variantsWorker = new Worker('/Pages/Search/Hotel/Variants/_Main/Scripts/pushNextPortion.hotel.variants.worker.es6.js'); // Путь к файлу воркера
        };
        window.search.hotel.variantsWorker.onmessage = async function (e) {
            let result = e.data;

            self.model.pushNextPortionResult(result);

            console.log(`percentage ${self.model.frontEnd.completionPercentage.toFixed(2)} (${window.utils.formatDuration(performance.now() - window.search.hotel.variants.totalProcessingStart)})`);
            if (self.model.frontEnd.completionPercentage !== 100 && typeof self.model.frontEnd.completionPercentage !== "undefined" && self.ajaxRequestsCounter < 100) {//если за 100 переопросов не получен финальный результат, то прекратим
                // инициализация переопроса со снижением частоты после 10 секунд
                await window.router.delay(self.ajaxRequestsCounter > 10 ? 10000 : 1000);
                await self.getMore();
            }
        };
        window.search.hotel.variantsWorker.onerror = function (error) {
            console.error("Worker error:", error);
        };
        self.getMore = async function () {
            console.log("More");

            const requestStart = performance.now(); // Засекаем время перед запросом
            let resp = await axios.get(window.globals.AbsolutePath + "/HotelVariants/More/", {
                params: {
                    hash: self.requestId,
                    timestamp: (self.timestamp || '0')
                }
            });

            const requestEnd = performance.now(); // Засекаем время после завершения запроса
            console.log(`Response received in ${window.utils.formatDuration(requestEnd - requestStart)}`);

            self.ajaxRequestsCounter++;
            self.timestamp = resp.data.timestamp;
            console.log("timestamp " + resp.data.timestamp);
            if (!!resp.data.hotels) {
                console.log("hotels length " + resp.data.hotels.length);
            }

            window.search.hotel.variants.totalProcessingStart = performance.now(); // Засекаем общее время перед обработкой данных

            //простые данные раскладываем в основном потоке
            self.model.pushPortionDictionaries(resp.data);

            //комплексные данные обрабатываются в фоне dedicated worker
            window.search.hotel.variantsWorker.postMessage({
                portion: resp.data,
                existingHotels: self.model.frontEnd.hotels,
                id_City: self.model.initials.startForm.id_City,
                startFormLatitude: self.model.initials.startForm.Latitude,
                startFormLongitude: self.model.initials.startForm.Longitude,
                extraFunctionsStrings: self.model.extraFunctionsOnPushNextPortion.map(func => func.toString()),
                completionPercentage: resp.data.completionPercentage
            });
        }

        //Переопределяем шаг выгрузки, очищая бандинги
        self.onUnload = function () {
            self.model.hotels = [];
        }
        self.onShow = function () { }

        return self;
    }();
});
$(function () {

    function hotelRatesModel(json) {
        return {
            el: "#hotel-rates",
            mixins: [...window.jv3.utils.mixins.retrieveMixings('rateVariantsModel'), ...window.jv3.utils.mixins.retrieveMixings('hotel-rates-v2')],
            data() {
                return {
                    isModelFlipped: false,
                    isModelActive: false,
                    slidesPerView: 4,
                    sliderHotelIndex: 0,
                    frontEnd: {
                        isExpandDescr: false,
                        isExpandRemark: false,
                        startData: null,// данные стартовой формы
                        currentHotelIndex: 0, //индекс текущего отеля
                        currentAccessor: null, //для хранения аксессора выбранного рейта
                        newPrice: null,
                        isInvalidNewPrice: false, //флаг ввода некорректной наценки
                        markup: 0, //величина наценки
                        currentRateOriginalHiddenServiceFee: 0,
                        filterFunctions: [],
                        recalculatePriceData: {
                            canRecalculate: false,
                            isPriceCalculating: false, // флаг управления спиннером во время пересчета цены
                            earlyCheckInOptions: { //модель раннего заезда
                                hasEarlyCheckIn: false,
                                selected: false,
                                earlyCheckInTime: 9,
                            },
                            lateCheckOutOptions: { //модель позднего выезда
                                hasLateCheckOut: false,
                                selected: false,
                                lateCheckOutTime: 19
                            }
                        },
                        sorting: {//эти пресеты соответствуют порядку поступающих данных
                            column: "price", // по какой колонке сортируем
                            direction: "asc", // направление для сортировки
                        },
                        travelPolicyViolations: [],
                    },
                    serverResponse: json,
                    baseSortMethod: null,//метод сортировки рейтов. может быть переопределен в миксине
                    modalsOpened: {
                        markupManagement: false,
                        travelPolicy: false,
                    },
                };
            },

            async mounted() {
                let _ths = this;
                if (!!this.serverResponse.StartForm) {
                    this.frontEnd.startData = this.serverResponse.StartForm;
                }
                else {
                    let resp = await axios.get(window.globals.AbsolutePath + '/HotelRates/HotelRates', {
                        params: this.serverResponse.HotelModel
                    });
                    this.frontEnd.startData = resp.data;
                }

                if (!this.baseSortMethod)
                    this.baseSortMethod = function (item1, item2) {
                        var value1, value2;
                        if (_ths.frontEnd.sorting.column == "price") {//по цене
                            value1 = _ths.getVariantByAccessor(item1.rates[0].uniqueAccessor).price.total;
                            value2 = _ths.getVariantByAccessor(item2.rates[0].uniqueAccessor).price.total;
                        }
                        if (_ths.frontEnd.sorting.column == "yeild") {//по доходности
                            value1 = _ths.getYeildOfVariant(item1.rates[0].uniqueAccessor);
                            value2 = _ths.getYeildOfVariant(item2.rates[0].uniqueAccessor);
                        }
                        if (_ths.frontEnd.sorting.column == "availability") {//по доступности
                            value1 = _ths.getAvailabilityOfVariant(item1);
                            value2 = _ths.getAvailabilityOfVariant(item2);
                        }
                        if (_ths.frontEnd.sorting.direction === "asc") // сортировка по возрастанию                                
                            return ((value1 < value2) ? -1 : (((value1 > value2)) ? 1 : 0));
                        else // сортировка по убыванию
                            return ((value1 > value2) ? -1 : (((value1 < value2)) ? 1 : 0));
                    };
            },

            computed: {
                //текущий отель
                currentHotel() {
                    if (!!this.frontEnd.startData) {
                        return this.frontEnd.startData.hotels[this.frontEnd.currentHotelIndex];
                    }
                },

                //текущий рейт
                currentRate() {
                    if (this.frontEnd.currentAccessor)
                        return this.getVariantByAccessor(this.frontEnd.currentAccessor);
                    return null;
                },

                //текущая валюта в которой выводятся цены
                computedDisplayCurrency() {
                    if (!!this.currentHotel)
                        return this.currentHotel.displayCurrencySettings.displayCurrency;
                },

                //признак вывода цены за ночь
                computedIsPricePerNight() {
                    if (!!this.currentHotel)
                        return this.currentHotel.displayCurrencySettings.isPricePerNight;
                },

                activeFiltersCount() {
                    return this.frontEnd.filterFunctions.reduce((cnt, item) =>
                        item.isActive() ? cnt + 1 : cnt, 0);
                },

                hasVisibleRates() {
                    return !!this.currentHotel.rateContainerList.filter(f => this.isVisibleRate(f)).length;
                }
            },
            methods: {
                toggleDescr() {
                    this.frontEnd.isExpandDescr = !this.frontEnd.isExpandDescr;
                },

                toggleRemark() {
                    this.frontEnd.isExpandRemark = !this.frontEnd.isExpandRemark;
                },

                //отправляет запрос изменения наценки
                async sendMarkupChangeRequest() {
                    let model = {
                        RequestId: this.frontEnd.startData.requestId,
                        RateUniqueAccessCode: this.currentRate.accessorForPrebooking,
                        HotelName: this.currentHotel.hotelInfo.name,
                        NormalizedName: this.currentHotel.hotelInfo.normalizedName,
                        NormalizedNameEn: this.currentHotel.hotelInfo.normalizedNameEn,
                        NewMarkup: this.frontEnd.markup,
                        Stars: this.currentHotel.hotelInfo.stars
                    };

                    let resp = await axios.get(window.globals.AbsolutePath + '/HotelRates/ChangeMarkup', {
                        params: model
                    });
                    return resp.data;
                },

                //возвращает список все поставщиков рейтов для данной группы
                getSuppliers(group) {
                    var _this = this;
                    return group.rates
                        .map(r => _this.supplierDecodeById(_this.getVariantByAccessor(r.uniqueAccessor).id_System))
                        .filter((value, index, self) => self.indexOf(value) === index);//distinct
                },
                // получает название поставщика по его ид
                supplierDecodeById(id_System) {
                    if (!this.frontEnd.startData.supplier || !this.frontEnd.startData.supplier.hasOwnProperty(id_System))
                        return "unknown";
                    return this.frontEnd.startData.supplier[id_System];
                },
                //Получаем рейт по идентификатору
                getVariantByAccessor(accessor) {
                    let res = this.currentHotel.rates
                        .find(r => r.uniqueAccessor === accessor);
                    return res;
                },

                //флаг крутилки на кнопке для группы рейтов
                isAnyFromGroupLoading(group) {
                    return group.rates
                        .some(r => this.getVariantByAccessor(r.uniqueAccessor).showLoading);
                },

                /* --ФИЛЬТРЫ-- */
                resetAllFilters() {
                    this.frontEnd.filterFunctions.forEach(item => item.reset());
                },
                isVisibleRate(groupByNameRate) {
                    let rate = this.getVariantByAccessor(groupByNameRate.rates[0].uniqueAccessor);
                    let result = true;
                    for (var i = 0; i < this.frontEnd.filterFunctions.length; i++)
                        result = result && this.frontEnd.filterFunctions[i].filter(rate);
                    return result;
                },
                /*-- ФИЛЬТРЫ КОНЕЦ --*/

                /*---------------------------- расчет цен ---------------------------------*/
                //получить стоимость с учетом выбранной валюты и периода с указанной валютой
                GetTotalPriceWithCurrency(accessor) {
                    let output = this.GetTotalPrice(accessor);
                    return this.getCurrencyString(output);
                },
                //получить стоимость с учетом выбранной валюты и периода
                GetTotalPrice(accessor) {
                    let rate = this.getVariantByAccessor(accessor);//get rate
                    let priceWithSurcharge = rate.price.total + rate.selectedCheckIn.surcharge + rate.selectedCheckOut.surcharge;
                    let output = this.EvalPriceForSelectedNights(priceWithSurcharge);
                    return this.EvalPriceForCurrency(output, rate);
                },
                //доходность по варианту с учетом выбранной валюты и периода
                getYeildOfVariant(accessor) {
                    let variant = this.getVariantByAccessor(accessor);//get rate
                    let yeildOfVariant = variant.price.serviceFee +
                        variant.price.commission +
                        variant.price.hiddenServiceFee -
                        variant.price.discount;
                    let output = this.EvalPriceForSelectedNights(yeildOfVariant);
                    return this.EvalPriceForCurrency(output, variant);
                },
                //доступность по варианту (корп тариф, моментальное подтверждение, под запрос + цена)
                getAvailabilityOfVariant(item) {
                    let price = this.getVariantByAccessor(item.rates[0].uniqueAccessor).price.total;
                    let is3d = item.is3d
                    let isOnRequest = this.getVariantByAccessor(item.rates[0].uniqueAccessor).isOnRequest;
                    let output = (is3d ? "1" : isOnRequest ? "3" : "2") + (Math.trunc(price * 100).toString().padStart(10, "0"));
                    return output;
                },
                //посчитать сумму для выбранной валюты
                EvalPriceForCurrency(rubPrice, currentRoom) {
                    let rateObject = this.currentHotel.displayCurrencySettings.currencies.filter(f => f.code == this.computedDisplayCurrency);
                    let rate = 1;
                    if (rateObject.length)
                        rate = rateObject[0].exchRate;
                    if (this.computedDisplayCurrency == currentRoom.price.currency)
                        rate = currentRoom.price.conversionRate;
                    if (rate == 1)
                        return rubPrice;
                    let output = (rubPrice / rate);
                    if (output % 1 != 0)
                        return output.toFixed(2);
                    return output.toFixed(0);
                },
                //посчитать сумму за весь период или одну ночь
                EvalPriceForSelectedNights(rubPrice) {
                    if (!this.currentHotel.displayCurrencySettings.isPricePerNight)
                        return rubPrice;
                    if (this.currentHotel.hotelInfo.totalNights == 1)
                        return rubPrice;
                    let output = (rubPrice / this.currentHotel.hotelInfo.totalNights);
                    if (output % 1 != 0)
                        return output.toFixed(2);
                    return output.toFixed(0);
                },

                //получить сумму с учетом выбранной валюты
                ConvertPriceToFilterRate(rubPrice, accessor) {
                    let rate = this.getVariantByAccessor(accessor);//get rate
                    let output = this.EvalPriceForSelectedNights(rubPrice);
                    output = this.EvalPriceForCurrency(output, rate);
                    return output;
                },

                //получить сумму с учетом выбранной валюты и вывести строкой с названием валюты
                ConvertPriceFilterBased(rubPrice, accessor) {
                    let convertedPrice = this.ConvertPriceToFilterRate(rubPrice, accessor);
                    return this.getCurrencyString(convertedPrice);
                },

                getRealExchangeRate(rate) {
                    let rateObject = this.currentHotel.priceFilter.currencies.filter(f => f.code == this.computedDisplayCurrency);
                    if (!rateObject.length)
                        return null;
                    if (rate.price.currency == this.computedDisplayCurrency && rate.price.conversionRate != rateObject[0].exchRate && this.computedDisplayCurrency != "RUB")
                        return jv3.utils.various.getCurrencyString(rate.price.conversionRate, this.currency.rub, this.currency.cop);
                    return null;
                },
                /*---------------------------- расчет цен закончен ---------------------------------*/
                //необходимые проверки перед переходом на пребукинг
                doChecksBeforeNextStep(accessor) {
                    this.frontEnd.currentAccessor = accessor;
                    let rate = this.getVariantByAccessor(accessor);
                    if ((rate.automaticEarlyCheckin || rate.automaticLateCheckout) && !(rate.checkInSurcharge.length || rate.checkOutSurcharge.length)) { //если ранний заезд и поздний выезд разрешен, но информации об тарифах не имеем, то открыть модал для перерасчета. 
                        //открыть модал пересчета цены
                        this.modalsOpened.ealdOverride = true;
                    }
                    else {//иначе следующий шаг
                        this.checkTravelPolicies();
                    }
                },

                //при смене времени раннего заезда обновить связанные рейты
                checkInTimeChanged(accessor, hour) {
                    this.checkInOutTimeChanged(accessor, hour, "In");
                },
                //при смене времени позднего выезда обновить связанные рейты
                checkOutTimeChanged(accessor, hour) {
                    this.checkInOutTimeChanged(accessor, hour, "Out");
                },
                //при смене времени раннего заезда/позднего выезда обновить связанные рейты
                checkInOutTimeChanged(accessor, hour, _direction) {
                    var selectedValuesFieldName = 'selectedCheck' + _direction;
                    var surchargeDictionary = 'check' + _direction + 'Surcharge';

                    this.frontEnd.currentAccessor = accessor;
                    var cr = this.currentRate;
                    cr[selectedValuesFieldName].hour = hour;
                    if (hour === null)
                        cr[selectedValuesFieldName].surcharge = 0;
                    else
                        cr[selectedValuesFieldName].surcharge = cr[surchargeDictionary].find(obj => obj.hour == hour).surcharge;//установить выбранную цену
                    //установить выбранное время и цену для рейтов в этом предложении
                    var ratesInItem = this.getRatesInItem(accessor);
                    this.currentHotel.rates.filter(obj => ratesInItem.includes(obj.uniqueAccessor)).forEach(function (rate) {
                        rate[selectedValuesFieldName].hour = hour;
                        rate[selectedValuesFieldName].surcharge = cr[selectedValuesFieldName].surcharge;
                    });
                    this.checkTravelPoliciesViolation();
                },
                //получение связанных рейтов по идентификатору рейта - если номер просматривается от разных агенств
                getRatesInItem(accessor) {//получить рейты в группе, содержащей рейт accessor                    
                    return this.currentHotel.rateContainerList.map(c => c.rates).reduce(function (previousValue, currentItem) {
                        var output = [];
                        if (currentItem.find(obj => obj.uniqueAccessor == accessor)) {
                            currentItem.filter(obj => obj.uniqueAccessor != accessor).forEach(function (el) {
                                output.push(el.uniqueAccessor);
                            });
                        }
                        if (Array.isArray(previousValue))
                            return output.concat(previousValue);
                        else return output;
                    }, 0);
                },
                //получить значение заголовка списка раннего заезда/позднего выезда
                getCheckInOutLabel(hour, _default) {
                    if (hour === null) return _default;
                    return hour + ":00";
                },
                //пересчитать цены
                async recalculateTotal() {
                    this.currentRate.showLoading = true;
                    this.frontEnd.recalculatePriceData.isPriceCalculating = true;

                    let resp = await axios.get(window.globals.AbsolutePath + '/HotelRates/RecalculatePrice', {
                        params: {
                            RequestId: this.frontEnd.startData.requestId,
                            HotelName: this.currentHotel.hotelInfo.name,
                            Stars: this.currentHotel.hotelInfo.stars,
                            HasCoordinates: this.currentHotel.hotelInfo.hasCoordinates,
                            Latitude: this.currentHotel.hotelInfo.lat,
                            Longitude: this.currentHotel.hotelInfo.lng,
                            rateUniqueAccessCode: this.currentRate.accessorForPrebooking,
                            rateCode: this.currentRate.rateCode,
                            agencyName: this.currentRate.agencyName,
                            earlyCheckInTime: this.frontEnd.recalculatePriceData.earlyCheckInOptions.selected ? this.frontEnd.recalculatePriceData.earlyCheckInOptions.earlyCheckInTime : null,
                            lateCheckOutTime: this.frontEnd.recalculatePriceData.lateCheckOutOptions.selected ? this.frontEnd.recalculatePriceData.lateCheckOutOptions.lateCheckOutTime : null,
                            Type: this.currentHotel.hotelInfo.type,
                            NormalizedName: this.currentHotel.hotelInfo.normalizedName,
                            NormalizedNameEn: this.currentHotel.hotelInfo.normalizedNameEn,
                        }
                    });
                    let data = resp.data;

                    if (!data.error) {
                        //устанавливает данные
                        this.currentRate.accessorForPrebooking = data.newUniqueAccessor;
                        this.currentRate.price.total = data.newTotalPrice + this.frontEnd.markup;
                        this.currentRate.price.basePrice = data.newBasePrice;
                        this.currentRate.price.serviceFee = data.newServiceFee;

                        //убираем начальный скрытый сбор и добавляем новый
                        this.currentRate.price.hiddenServiceFee = this.currentRate.price.hiddenServiceFee - this.currentRateOriginalHiddenServiceFee + data.newHiddenServiceFee;
                        this.currentRateOriginalHiddenServiceFee = data.newHiddenServiceFee; //пересохраняем начальный скрытый сбор на случай дальнейших пересчетов цены

                        await this.sendMarkupChangeRequest(); //пересохраняем наценку

                        this.frontEnd.recalculatePriceData.canRecalculate = false;

                        //установить значения рзпв рейта
                        this.currentRate.selectedCheckIn.hour = this.frontEnd.recalculatePriceData.earlyCheckInOptions.selected ?
                            this.frontEnd.recalculatePriceData.earlyCheckInOptions.earlyCheckInTime : null;
                        this.currentRate.selectedCheckOut.hour = this.frontEnd.recalculatePriceData.lateCheckOutOptions.selected ?
                            this.frontEnd.recalculatePriceData.lateCheckOutOptions.lateCheckOutTime : null;
                        this.currentRate.selectedCheckIn.surcharge = !!data.selectedCheckInSurcharge ? data.selectedCheckInSurcharge : 0;
                        this.currentRate.selectedCheckOut.surcharge = !!data.selectedCheckOutSurcharge ? data.selectedCheckOutSurcharge : 0;
                    }
                    else {
                        this.modalsOpened.ealdOverride = false;
                        this.frontEnd.recalculatePriceData.canRecalculate = true;
                        //оповещение об ошибке
                        swal({
                            text: data.error,
                            type: 'error',
                            allowOutsideClick: false,
                            confirmButtonClass: 'btn btn-primary'
                        });
                    }

                    this.currentRate.showLoading = false;
                    this.frontEnd.recalculatePriceData.isPriceCalculating = false;
                },

                //проверка тп при смене РЗПВ
                async checkTravelPoliciesViolation() {
                    let resp = await axios.get(window.globals.AbsolutePath + '/HotelRates/CheckTravelPoliciesViolation', {
                        params: {
                            RequestId: this.frontEnd.startData.requestId,
                            RateUniqueAccessCode: this.currentRate.accessorForPrebooking,
                            HotelName: this.currentHotel.hotelInfo.name,
                            NormalizedName: this.currentHotel.hotelInfo.normalizedName,
                            Stars: this.currentHotel.hotelInfo.stars,
                            NewCheckInTime: this.currentRate.selectedCheckIn.hour,
                            NewCheckOutTime: this.currentRate.selectedCheckOut.hour
                        }
                    });

                    console.log(resp.data);

                    let data = resp.data;
                    var rateContainer = this.currentHotel.rateContainerList.filter(f => f.rates.length && f.rates.some(s => s.uniqueAccessor == this.currentRate.accessorForPrebooking))[0];
                    if (rateContainer) if (data == 'ok')
                        rateContainer.travelPolicy.violations = null;
                    else {
                        if ((typeof data === 'string' || data instanceof String)) {
                            rateContainer.travelPolicy.violations = JSON.parse(data);
                        }
                        else {
                            rateContainer.travelPolicy.violations = data;
                        }
                    }
                },

                //переход на пребукинг
                async goToPrebooking() {

                    this.currentRate.showLoading = true;

                    let model = {
                        RequestId: this.frontEnd.startData.requestId,
                        RateUniqueAccessCode: this.currentRate.accessorForPrebooking,
                        HotelName: this.currentHotel.hotelInfo.name,
                        NormalizedName: this.currentHotel.hotelInfo.normalizedName,
                        NormalizedNameEn: this.currentHotel.hotelInfo.normalizedNameEn,
                        Stars: this.currentHotel.hotelInfo.stars,
                        NewMarkup: this.frontEnd.markup,
                    };

                    model.NewCheckInTime = this.currentRate.selectedCheckIn.hour;
                    model.NewCheckOutTime = this.currentRate.selectedCheckOut.hour;

                    await axios.post('/HotelRates/StoreRate', model);
					
                    // после сохранения рейтов, страница может быть уже закрыта, и this.currentRate становится недоступным
                    if (this.currentRate)
                        this.currentRate.showLoading = false;

                    window.router.next();

                },
                /*--сортировка--*/
                onChangeSortingParameter(key) {
                    this.frontEnd.sorting.column = key;
                    this.baseSort();
                },
                onChangeSortingDirection(key) {
                    this.frontEnd.sorting.direction = key;
                    this.baseSort();
                },

                //основной метод сортировки
                baseSort() {
                    if (!!this.currentHotel) {
                        //let prices = this.currentHotel.rateContainerList.map(item => this.getVariantByAccessor(item.rates[0].uniqueAccessor).price.total);
                        //console.log("До сортировки:", prices);
                        const sortedData = [...this.currentHotel.rateContainerList].sort(this.baseSortMethod);
                        this.currentHotel.rateContainerList = sortedData;
                        //prices = this.currentHotel.rateContainerList.map(item => this.getVariantByAccessor(item.rates[0].uniqueAccessor).price.total);
                        //console.log("После сортировки (prices):", prices);
                    }
                },
                /*--конец сортировки--*/
                //сумму в красивую строку округленно
                getCurrencyString(sum, suppress) {
                    let output = "";
                    if (this.currentHotel.displayCurrencySettings.displayCurrency == "RUB" || suppress)
                        output = jv3.utils.various.getCurrencyString(sum, this.frontEnd.startData.currencyLocals.rub, this.frontEnd.startData.currencyLocals.cop);
                    else
                        output = `${sum} ${this.currentHotel.displayCurrencySettings.displayCurrency}`;
                    if (this.currentHotel.displayCurrencySettings.isPricePerNight && !suppress)
                        output += "/" + this.currentHotel.displayCurrencySettings.pricePerNightString;
                    return output;
                },
                getCurrencyName(code) {
                    if (code === "RUB")
                        return globals.Language === "RU" ? "руб" : "rub";
                    return code;
                },

                //удалить небезопасные символы из строки
                removeUnsafeSymbols(unsafe) {
                    return unsafe
                        .replace(/&/g, "")
                        .replace(/</g, "")
                        .replace(/>/g, "")
                        .replace(/"/g, "")
                        .replace(/'/g, "");
                },
                //получить инфо агентств, предоставляющих этот рейт
                GetAgencies(rate) {
                    if (!this.frontEnd.startData.agencies || this.frontEnd.startData.agencies.length < 2)
                        return null;
                    var info = this.frontEnd.startData.agencies.filter(f => rate.agencies.includes(f.id));
                    if (!info) return null;
                    return info.map(function (item) {
                        return { name: item.name };
                    });
                },
                //получить название агентства
                GetAgencyInfo(id_Agency) {
                    if (!this.frontEnd.startData.agencies)
                        return {};
                    var info = this.frontEnd.startData.agencies.find(f => f.id == id_Agency);
                    if (!info) return {};
                    return info;
                },
                async changeMarkup() {
                    this.frontEnd.markup = this.frontEnd.newPrice - this.currentRate.price.total
                    let data = await this.sendMarkupChangeRequest();
                    if (data == "ok") {
                        this.modalsOpened.markupManagement = false;
                        this.currentRate.price.hiddenServiceFee += this.frontEnd.markup; //наценка добавлена - запишем ее в скрытый сбор
                        this.currentRate.price.total += this.frontEnd.markup;
                        if (!!this.currentHotel.filters.priceFilter) {//если маркап больше самого дорогого номера, то рейт выпадает из дефолтового фильтра по цене, поправить
                            if (this.currentHotel.filters.priceFilter.filterSettings.currentMax == this.currentHotel.filters.priceFilter.filterSettings.maxPrice) {
                                if (this.currentRate.price.total > this.currentHotel.filters.priceFilter.filterSettings.maxPrice) {
                                    this.currentHotel.filters.priceFilter.filterSettings.currentMax = this.currentRate.price.total;
                                }
                            }
                        }
                    }
                },
                //показывает модал с наценкой
                showMarkupModal(accessor) {
                    this.frontEnd.currentAccessor = accessor;
                    this.frontEnd.newPrice = null;
                    this.frontEnd.markup = 0;
                    //сохранение начального сбора нужно для корректного подсчета стоимости 
                    //после возможного пересчета цены из- за раннего заезда/ позднего выезда
                    this.currentRateOriginalHiddenServiceFee = this.currentRate.price.hiddenServiceFee;

                    this.modalsOpened.markupManagement = true;
                },
                async checkTravelPoliciesBase() {
                    let resp = await axios.get(window.globals.AbsolutePath + "/HotelRates/CheckTravelPolicies", {
                        params: {
                            requestId: this.frontEnd.startData.requestId,
                            rateUniqueAccessCode: this.currentRate.accessorForPrebooking,
                            hotelName: this.currentHotel.hotelInfo.name,
                            normalizedName: this.currentHotel.hotelInfo.normalizedName,
                            stars: this.currentHotel.hotelInfo.stars,
                            NewCheckInTime: this.currentRate.selectedCheckIn.hour,
                            NewCheckOutTime: this.currentRate.selectedCheckOut.hour
                        }
                    });
                    if (resp.data === "ok") {
                        this.frontEnd.travelPolicyViolations = [];
                        await this.goToPrebooking();
                        return;
                    }

                    this.frontEnd.travelPolicyViolations = [...resp.data.map(p => {
                        if (window.globals.Language === 'RU') {
                            return { name: p.PolicyName.RussianText, description: p.DescriptionText.RussianText };
                        } else {
                            return { name: p.PolicyName.EnglishText, description: p.DescriptionText.EnglishText };
                        }
                    })];
                    this.frontEnd.travelPolicyViolations = this.frontEnd.travelPolicyViolations.sort((a, b) => a.name < b.name ? -1 : 1)
                }
            },

            watch: {
                // https://ru.yougile.com/team/a545e11632b6/#REF-1754
                // this.baseSort() не сортировал как надо, если вызывается в mounted
                'frontEnd.startData': {
                    handler() {
                        if (this.currentHotel) {
                            this.baseSort();
                        }
                    },
                    deep: false, // Не отслеживаем вложенные изменения, чтобы сортировка рейтов не зациклилась
                    immediate: true
                },

                'frontEnd.newPrice': function () {
                    if (!this.frontEnd.newPrice ||
                        this.frontEnd.newPrice < this.currentRate.price.total - this.currentRate.price.hiddenServiceFee) {
                        this.frontEnd.isInvalidNewPrice = true;
                    }
                    else {
                        this.frontEnd.isInvalidNewPrice = false;
                    }
                },
                //изменен выбранный рейт
                currentRate() {
                    //установить начальные значения для модала пересчета цен
                    this.frontEnd.recalculatePriceData.canRecalculate = false;
                    this.frontEnd.recalculatePriceData.earlyCheckInOptions.hasEarlyCheckIn = false;
                    this.frontEnd.recalculatePriceData.earlyCheckInOptions.selected = false;
                    this.frontEnd.recalculatePriceData.earlyCheckInOptions.earlyCheckInTime = 9;

                    this.frontEnd.recalculatePriceData.lateCheckOutOptions.hasLateCheckOut = false;
                    this.frontEnd.recalculatePriceData.lateCheckOutOptions.selected = false;
                    this.frontEnd.recalculatePriceData.lateCheckOutOptions.lateCheckOutTime = 19;

                    this.frontEnd.markup = 0;
                },

                'frontEnd.recalculatePriceData.earlyCheckInOptions.selected': function (val) { //если хотя бы один из чекбоксов выбран, пересчитываем
                    if (val || this.frontEnd.recalculatePriceData.lateCheckOutOptions.selected || (!val && !this.frontEnd.recalculatePriceData.canRecalculate))
                        this.frontEnd.recalculatePriceData.canRecalculate = true;
                    else
                        this.frontEnd.recalculatePriceData.canRecalculate = false;
                },

                'frontEnd.recalculatePriceData.lateCheckOutOptions.selected': function (val) {
                    if (val || this.frontEnd.recalculatePriceData.earlyCheckInOptions.selected || (!val && !this.frontEnd.recalculatePriceData.canRecalculate))
                        this.frontEnd.recalculatePriceData.canRecalculate = true;
                    else
                        this.frontEnd.recalculatePriceData.canRecalculate = false;
                },

                'frontEnd.recalculatePriceData.earlyCheckInOptions.earlyCheckInTime': function () {
                    this.frontEnd.recalculatePriceData.canRecalculate = true;
                },

                'frontEnd.recalculatePriceData.lateCheckOutOptions.lateCheckOutTime': function () {
                    this.frontEnd.recalculatePriceData.canRecalculate = true;
                },
            }
        }
    };

    // МОДЕЛЬ СПИСКА НОМЕРОВ
    // Используется во вьюхах:
    //          Pages\Search\Hotel\Rates\Views\Desktop\Rates.cshtml
    //          Pages\Search\Hotel\Rates\Views\Mobile\Rates.cshtml
    // инициализация контейнера для js-моделей
    if (!window.search)
        window.search = {};
    if (!window.search.hotel)
        window.search.hotel = {
            index: null
        };

    window.search.hotel.rates = function () {
        var self = new baseStepModel();

        self.model = null;

        self.onLoad = function (json) {
            self.model = new Vue(new hotelRatesModel(json));

        }
        // вызывается при показе шага
        self.onShow = function () {
            (function ($) {
                $(document).ready(function () {
                    window.dispatchEvent(new CustomEvent('IExtraView.Ready'));

                    var ieWorkaround = async function () {
                        //в ие страница отображается не полностью, но если передернуть стили, то начинает отображаться правильно. передергивание стилей выполняет force redraw page. это воркэраунд для ие. ие зло
                        $('#hotel-step3').removeClass('flip-in');
                        await jv3.utils.various.sleep(500);
                        $('#hotel-step3').addClass('flip-in');
                    };
                    if (!jv3.utils.various.detectIE()) return;
                    ieWorkaround();
                });
            })(jQuery);
        }

        self.onUnload = function () { }

        return self;
    }();
});
;
// -- Sammy.js -- /sammy.js
// http://sammyjs.org
// Version: 0.7.6
// Built: 2014-08-26 10:45:34 +0300
(function(factory){if(typeof define==="function"&&define.amd){define(["jquery"],factory)}else{jQuery.sammy=window.Sammy=factory(jQuery)}})(function($){var Sammy,PATH_REPLACER="([^/]+)",PATH_NAME_MATCHER=/:([\w\d]+)/g,QUERY_STRING_MATCHER=/\?([^#]*)?$/,_makeArray=function(nonarray){return Array.prototype.slice.call(nonarray)},_isFunction=function(obj){return Object.prototype.toString.call(obj)==="[object Function]"},_isArray=function(obj){return Object.prototype.toString.call(obj)==="[object Array]"},_isRegExp=function(obj){return Object.prototype.toString.call(obj)==="[object RegExp]"},_decode=function(str){return decodeURIComponent((str||"").replace(/\+/g," "))},_encode=encodeURIComponent,_escapeHTML=function(s){return String(s).replace(/&(?!\w+;)/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;")},_routeWrapper=function(verb){return function(){return this.route.apply(this,[verb].concat(Array.prototype.slice.call(arguments)))}},_template_cache={},_has_history=!!(window.history&&history.pushState),loggers=[];Sammy=function(){var args=_makeArray(arguments),app,selector;Sammy.apps=Sammy.apps||{};if(args.length===0||args[0]&&_isFunction(args[0])){return Sammy.apply(Sammy,["body"].concat(args))}else if(typeof(selector=args.shift())=="string"){app=Sammy.apps[selector]||new Sammy.Application;app.element_selector=selector;if(args.length>0){$.each(args,function(i,plugin){app.use(plugin)})}if(app.element_selector!=selector){delete Sammy.apps[selector]}Sammy.apps[app.element_selector]=app;return app}};Sammy.VERSION="0.7.6";Sammy.addLogger=function(logger){loggers.push(logger)};Sammy.log=function(){var args=_makeArray(arguments);args.unshift("["+Date()+"]");$.each(loggers,function(i,logger){logger.apply(Sammy,args)})};if(typeof window.console!="undefined"){if(typeof window.console.log==="function"&&_isFunction(window.console.log.apply)){Sammy.addLogger(function(){window.console.log.apply(window.console,arguments)})}else{Sammy.addLogger(function(){window.console.log(arguments)})}}else if(typeof console!="undefined"){Sammy.addLogger(function(){console.log.apply(console,arguments)})}$.extend(Sammy,{makeArray:_makeArray,isFunction:_isFunction,isArray:_isArray});Sammy.Object=function(obj){return $.extend(this,obj||{})};$.extend(Sammy.Object.prototype,{escapeHTML:_escapeHTML,h:_escapeHTML,toHash:function(){var json={};$.each(this,function(k,v){if(!_isFunction(v)){json[k]=v}});return json},toHTML:function(){var display="";$.each(this,function(k,v){if(!_isFunction(v)){display+="<strong>"+k+"</strong> "+v+"<br />"}});return display},keys:function(attributes_only){var keys=[];for(var property in this){if(!_isFunction(this[property])||!attributes_only){keys.push(property)}}return keys},has:function(key){return this[key]&&$.trim(this[key].toString())!==""},join:function(){var args=_makeArray(arguments);var delimiter=args.shift();return args.join(delimiter)},log:function(){Sammy.log.apply(Sammy,arguments)},toString:function(include_functions){var s=[];$.each(this,function(k,v){if(!_isFunction(v)||include_functions){s.push('"'+k+'": '+v.toString())}});return"Sammy.Object: {"+s.join(",")+"}"}});Sammy.targetIsThisWindow=function targetIsThisWindow(event,tagName){var targetElement=$(event.target).closest(tagName);if(targetElement.length===0){return true}var targetWindow=targetElement.attr("target");if(!targetWindow||targetWindow===window.name||targetWindow==="_self"){return true}if(targetWindow==="_blank"){return false}if(targetWindow==="top"&&window===window.top){return true}return false};Sammy.DefaultLocationProxy=function(app,run_interval_every){this.app=app;this.is_native=false;this.has_history=_has_history;this._startPolling(run_interval_every)};Sammy.DefaultLocationProxy.fullPath=function(location_obj){var matches=location_obj.toString().match(/^[^#]*(#.+)$/);var hash=matches?matches[1]:"";return[location_obj.pathname,location_obj.search,hash].join("")};$.extend(Sammy.DefaultLocationProxy.prototype,{bind:function(){var proxy=this,app=this.app,lp=Sammy.DefaultLocationProxy;$(window).bind("hashchange."+this.app.eventNamespace(),function(e,non_native){if(proxy.is_native===false&&!non_native){proxy.is_native=true;window.clearInterval(lp._interval);lp._interval=null}app.trigger("location-changed")});if(_has_history&&!app.disable_push_state){$(window).bind("popstate."+this.app.eventNamespace(),function(e){app.trigger("location-changed")});$(document).delegate("a","click.history-"+this.app.eventNamespace(),function(e){if(e.isDefaultPrevented()||e.metaKey||e.ctrlKey){return}var full_path=lp.fullPath(this),hostname=this.hostname?this.hostname:function(a){var l=document.createElement("a");l.href=a.href;return l.hostname}(this);if(hostname==window.location.hostname&&app.lookupRoute("get",full_path)&&Sammy.targetIsThisWindow(e,"a")){e.preventDefault();proxy.setLocation(full_path);return false}})}if(!lp._bindings){lp._bindings=0}lp._bindings++},unbind:function(){$(window).unbind("hashchange."+this.app.eventNamespace());$(window).unbind("popstate."+this.app.eventNamespace());$(document).undelegate("a","click.history-"+this.app.eventNamespace());Sammy.DefaultLocationProxy._bindings--;if(Sammy.DefaultLocationProxy._bindings<=0){window.clearInterval(Sammy.DefaultLocationProxy._interval);Sammy.DefaultLocationProxy._interval=null}},getLocation:function(){return Sammy.DefaultLocationProxy.fullPath(window.location)},setLocation:function(new_location){if(/^([^#\/]|$)/.test(new_location)){if(_has_history&&!this.app.disable_push_state){new_location="/"+new_location}else{new_location="#!/"+new_location}}if(new_location!=this.getLocation()){if(_has_history&&!this.app.disable_push_state&&/^\//.test(new_location)){history.pushState({path:new_location},window.title,new_location);this.app.trigger("location-changed")}else{return window.location=new_location}}},_startPolling:function(every){var proxy=this;if(!Sammy.DefaultLocationProxy._interval){if(!every){every=10}var hashCheck=function(){var current_location=proxy.getLocation();if(typeof Sammy.DefaultLocationProxy._last_location=="undefined"||current_location!=Sammy.DefaultLocationProxy._last_location){window.setTimeout(function(){$(window).trigger("hashchange",[true])},0)}Sammy.DefaultLocationProxy._last_location=current_location};hashCheck();Sammy.DefaultLocationProxy._interval=window.setInterval(hashCheck,every)}}});Sammy.Application=function(app_function){var app=this;this.routes={};this.listeners=new Sammy.Object({});this.arounds=[];this.befores=[];this.namespace=(new Date).getTime()+"-"+parseInt(Math.random()*1e3,10);this.context_prototype=function(){Sammy.EventContext.apply(this,arguments)};this.context_prototype.prototype=new Sammy.EventContext;if(_isFunction(app_function)){app_function.apply(this,[this])}if(!this._location_proxy){this.setLocationProxy(new Sammy.DefaultLocationProxy(this,this.run_interval_every))}if(this.debug){this.bindToAllEvents(function(e,data){app.log(app.toString(),e.cleaned_type,data||{})})}};Sammy.Application.prototype=$.extend({},Sammy.Object.prototype,{ROUTE_VERBS:["get","post","put","delete"],APP_EVENTS:["run","unload","lookup-route","run-route","route-found","event-context-before","event-context-after","changed","error","check-form-submission","redirect","location-changed"],_last_route:null,_location_proxy:null,_running:false,element_selector:"body",debug:false,raise_errors:false,run_interval_every:50,disable_push_state:false,template_engine:null,toString:function(){return"Sammy.Application:"+this.element_selector},$element:function(selector){return selector?$(this.element_selector).find(selector):$(this.element_selector)},use:function(){var args=_makeArray(arguments),plugin=args.shift(),plugin_name=plugin||"";try{args.unshift(this);if(typeof plugin=="string"){plugin_name="Sammy."+plugin;plugin=Sammy[plugin]}plugin.apply(this,args)}catch(e){if(typeof plugin==="undefined"){this.error("Plugin Error: called use() but plugin ("+plugin_name.toString()+") is not defined",e)}else if(!_isFunction(plugin)){this.error("Plugin Error: called use() but '"+plugin_name.toString()+"' is not a function",e)}else{this.error("Plugin Error",e)}}return this},setLocationProxy:function(new_proxy){var original_proxy=this._location_proxy;this._location_proxy=new_proxy;if(this.isRunning()){if(original_proxy){original_proxy.unbind()}this._location_proxy.bind()}},log:function(){Sammy.log.apply(Sammy,Array.prototype.concat.apply([this.element_selector],arguments))},route:function(verb,path){var app=this,param_names=[],add_route,path_match,callback=Array.prototype.slice.call(arguments,2);if(callback.length===0&&_isFunction(path)){callback=[path];path=verb;verb="any"}verb=verb.toLowerCase();if(path.constructor==String){PATH_NAME_MATCHER.lastIndex=0;while((path_match=PATH_NAME_MATCHER.exec(path))!==null){param_names.push(path_match[1])}path=new RegExp(path.replace(PATH_NAME_MATCHER,PATH_REPLACER)+"$")}$.each(callback,function(i,cb){if(typeof cb==="string"){callback[i]=app[cb]}});add_route=function(with_verb){var r={verb:with_verb,path:path,callback:callback,param_names:param_names};app.routes[with_verb]=app.routes[with_verb]||[];app.routes[with_verb].push(r)};if(verb==="any"){$.each(this.ROUTE_VERBS,function(i,v){add_route(v)})}else{add_route(verb)}return this},get:_routeWrapper("get"),post:_routeWrapper("post"),put:_routeWrapper("put"),del:_routeWrapper("delete"),any:_routeWrapper("any"),mapRoutes:function(route_array){var app=this;$.each(route_array,function(i,route_args){app.route.apply(app,route_args)});return this},eventNamespace:function(){return["sammy-app",this.namespace].join("-")},bind:function(name,data,callback){var app=this;if(typeof callback=="undefined"){callback=data}var listener_callback=function(){var e,context,data;e=arguments[0];data=arguments[1];if(data&&data.context){context=data.context;delete data.context}else{context=new app.context_prototype(app,"bind",e.type,data,e.target)}e.cleaned_type=e.type.replace(app.eventNamespace(),"");callback.apply(context,[e,data])};if(!this.listeners[name]){this.listeners[name]=[]}this.listeners[name].push(listener_callback);if(this.isRunning()){this._listen(name,listener_callback)}return this},trigger:function(name,data){this.$element().trigger([name,this.eventNamespace()].join("."),[data]);return this},refresh:function(){this.last_location=null;this.trigger("location-changed");return this},before:function(options,callback){if(_isFunction(options)){callback=options;options={}}this.befores.push([options,callback]);return this},after:function(callback){return this.bind("event-context-after",callback)},around:function(callback){this.arounds.push(callback);return this},onComplete:function(callback){this._onComplete=callback;return this},isRunning:function(){return this._running},helpers:function(extensions){$.extend(this.context_prototype.prototype,extensions);return this},helper:function(name,method){this.context_prototype.prototype[name]=method;return this},run:function(start_url){if(this.isRunning()){return false}var app=this;$.each(this.listeners.toHash(),function(name,callbacks){$.each(callbacks,function(i,listener_callback){app._listen(name,listener_callback)})});this.trigger("run",{start_url:start_url});this._running=true;this.last_location=null;if(!/\#(.+)/.test(this.getLocation())&&typeof start_url!="undefined"){this.setLocation(start_url)}this._checkLocation();this._location_proxy.bind();this.bind("location-changed",function(){app._checkLocation()});this.bind("submit",function(e){if(!Sammy.targetIsThisWindow(e,"form")){return true}var returned=app._checkFormSubmission($(e.target).closest("form"));return returned===false?e.preventDefault():false});$(window).bind("unload",function(){app.unload()});return this.trigger("changed")},unload:function(){if(!this.isRunning()){return false}var app=this;this.trigger("unload");this._location_proxy.unbind();this.$element().unbind("submit").removeClass(app.eventNamespace());$.each(this.listeners.toHash(),function(name,listeners){$.each(listeners,function(i,listener_callback){app._unlisten(name,listener_callback)})});this._running=false;return this},destroy:function(){this.unload();delete Sammy.apps[this.element_selector];return this},bindToAllEvents:function(callback){var app=this;$.each(this.APP_EVENTS,function(i,e){app.bind(e,callback)});$.each(this.listeners.keys(true),function(i,name){if($.inArray(name,app.APP_EVENTS)==-1){app.bind(name,callback)}});return this},routablePath:function(path){return path.replace(QUERY_STRING_MATCHER,"")},lookupRoute:function(verb,path){var app=this,routed=false,i=0,l,route;if(typeof this.routes[verb]!="undefined"){l=this.routes[verb].length;for(;i<l;i++){route=this.routes[verb][i];if(app.routablePath(path).match(route.path)){routed=route;break}}}return routed},runRoute:function(verb,path,params,target){var app=this,route=this.lookupRoute(verb,path),context,wrapped_route,arounds,around,befores,before,callback_args,path_params,final_returned;if(this.debug){this.log("runRoute",[verb,path].join(" "))}this.trigger("run-route",{verb:verb,path:path,params:params});if(typeof params=="undefined"){params={}}$.extend(params,this._parseQueryString(path));if(route){this.trigger("route-found",{route:route});if((path_params=route.path.exec(this.routablePath(path)))!==null){path_params.shift();$.each(path_params,function(i,param){if(route.param_names[i]){params[route.param_names[i]]=_decode(param)}else{if(!params.splat){params.splat=[]}params.splat.push(_decode(param))}})}context=new this.context_prototype(this,verb,path,params,target);arounds=this.arounds.slice(0);befores=this.befores.slice(0);callback_args=[context];if(params.splat){callback_args=callback_args.concat(params.splat)}wrapped_route=function(){var returned,i,nextRoute;while(befores.length>0){before=befores.shift();if(app.contextMatchesOptions(context,before[0])){returned=before[1].apply(context,[context]);if(returned===false){return false}}}app.last_route=route;context.trigger("event-context-before",{context:context});if(typeof route.callback==="function"){route.callback=[route.callback]}if(route.callback&&route.callback.length){i=-1;nextRoute=function(){i++;if(route.callback[i]){returned=route.callback[i].apply(context,callback_args)}else if(app._onComplete&&typeof(app._onComplete==="function")){app._onComplete(context)}};callback_args.push(nextRoute);nextRoute()}context.trigger("event-context-after",{context:context});return returned};$.each(arounds.reverse(),function(i,around){var last_wrapped_route=wrapped_route;wrapped_route=function(){return around.apply(context,[last_wrapped_route])}});try{final_returned=wrapped_route()}catch(e){this.error(["500 Error",verb,path].join(" "),e)}return final_returned}else{return this.notFound(verb,path)}},contextMatchesOptions:function(context,match_options,positive){var options=match_options;if(typeof options==="string"||_isRegExp(options)){options={path:options}}if(typeof positive==="undefined"){positive=true}if($.isEmptyObject(options)){return true}if(_isArray(options.path)){var results,numopt,opts,len;results=[];for(numopt=0,len=options.path.length;numopt<len;numopt+=1){opts=$.extend({},options,{path:options.path[numopt]});results.push(this.contextMatchesOptions(context,opts))}var matched=$.inArray(true,results)>-1?true:false;return positive?matched:!matched}if(options.only){return this.contextMatchesOptions(context,options.only,true)}else if(options.except){return this.contextMatchesOptions(context,options.except,false)}var path_matched=true,verb_matched=true;if(options.path){if(!_isRegExp(options.path)){options.path=new RegExp(options.path.toString()+"$")}path_matched=options.path.test(context.path)}if(options.verb){if(typeof options.verb==="string"){verb_matched=options.verb===context.verb}else{verb_matched=options.verb.indexOf(context.verb)>-1}}return positive?verb_matched&&path_matched:!(verb_matched&&path_matched)},getLocation:function(){return this._location_proxy.getLocation()},setLocation:function(new_location){return this._location_proxy.setLocation(new_location)},swap:function(content,callback){var $el=this.$element().html(content);if(_isFunction(callback)){callback(content)}return $el},templateCache:function(key,value){if(typeof value!="undefined"){return _template_cache[key]=value}else{return _template_cache[key]}},clearTemplateCache:function(){return _template_cache={}},notFound:function(verb,path){var ret=this.error(["404 Not Found",verb,path].join(" "));return verb==="get"?ret:true},error:function(message,original_error){if(!original_error){original_error=new Error}original_error.message=[message,original_error.message].join(" ");this.trigger("error",{message:original_error.message,error:original_error});if(this.raise_errors){throw original_error}else{this.log(original_error.message,original_error)}},_checkLocation:function(){var location,returned;location=this.getLocation();if(!this.last_location||this.last_location[0]!="get"||this.last_location[1]!=location){this.last_location=["get",location];returned=this.runRoute("get",location)}return returned},_getFormVerb:function(form){var $form=$(form),verb,$_method;$_method=$form.find('input[name="_method"]');if($_method.length>0){verb=$_method.val()}if(!verb){verb=$form[0].getAttribute("method")}if(!verb||verb===""){verb="get"}return $.trim(verb.toString().toLowerCase())},_checkFormSubmission:function(form){var $form,path,verb,params,returned;this.trigger("check-form-submission",{form:form});$form=$(form);path=$form.attr("action")||"";verb=this._getFormVerb($form);if(this.debug){this.log("_checkFormSubmission",$form,path,verb)}if(verb==="get"){params=this._serializeFormParams($form);if(params!==""){path+="?"+params}this.setLocation(path);returned=false}else{params=$.extend({},this._parseFormParams($form));returned=this.runRoute(verb,path,params,form.get(0))}return typeof returned=="undefined"?false:returned},_serializeFormParams:function($form){var queryString="",fields=$form.serializeArray(),i;if(fields.length>0){queryString=this._encodeFormPair(fields[0].name,fields[0].value);for(i=1;i<fields.length;i++){queryString=queryString+"&"+this._encodeFormPair(fields[i].name,fields[i].value)}}return queryString},_encodeFormPair:function(name,value){return _encode(name)+"="+_encode(value)},_parseFormParams:function($form){var params={},form_fields=$form.serializeArray(),i;for(i=0;i<form_fields.length;i++){params=this._parseParamPair(params,form_fields[i].name,form_fields[i].value)}return params},_parseQueryString:function(path){var params={},parts,pairs,pair,i;parts=path.match(QUERY_STRING_MATCHER);if(parts&&parts[1]){pairs=parts[1].split("&");for(i=0;i<pairs.length;i++){pair=pairs[i].split("=");params=this._parseParamPair(params,_decode(pair[0]),_decode(pair[1]||""))}}return params},_parseParamPair:function(params,key,value){if(typeof params[key]!=="undefined"){if(_isArray(params[key])){params[key].push(value)}else{params[key]=[params[key],value]}}else{params[key]=value}return params},_listen:function(name,callback){return this.$element().bind([name,this.eventNamespace()].join("."),callback)},_unlisten:function(name,callback){return this.$element().unbind([name,this.eventNamespace()].join("."),callback)}});Sammy.RenderContext=function(event_context){this.event_context=event_context;this.callbacks=[];this.previous_content=null;this.content=null;this.next_engine=false;this.waiting=false};Sammy.RenderContext.prototype=$.extend({},Sammy.Object.prototype,{then:function(callback){if(!_isFunction(callback)){if(typeof callback==="string"&&callback in this.event_context){var helper=this.event_context[callback];callback=function(content){return helper.apply(this.event_context,[content])}}else{return this}}var context=this;if(this.waiting){this.callbacks.push(callback)}else{this.wait();window.setTimeout(function(){var returned=callback.apply(context,[context.content,context.previous_content]);if(returned!==false){context.next(returned)}},0)}return this},wait:function(){this.waiting=true},next:function(content){this.waiting=false;if(typeof content!=="undefined"){this.previous_content=this.content;this.content=content}if(this.callbacks.length>0){this.then(this.callbacks.shift())}},load:function(location,options,callback){var context=this;return this.then(function(){var should_cache,cached,is_json,location_array;if(_isFunction(options)){callback=options;options={}}else{options=$.extend({},options)}if(callback){this.then(callback)}if(typeof location==="string"){is_json=location.match(/\.json(\?|$)/)||options.json;should_cache=is_json?options.cache===true:options.cache!==false;context.next_engine=context.event_context.engineFor(location);delete options.cache;delete options.json;if(options.engine){context.next_engine=options.engine;delete options.engine}if(should_cache&&(cached=this.event_context.app.templateCache(location))){return cached}this.wait();$.ajax($.extend({url:location,data:{},dataType:is_json?"json":"text",type:"get",success:function(data){if(should_cache){context.event_context.app.templateCache(location,data)}context.next(data)}},options));return false}else{if(location.nodeType){return location.innerHTML}if(location.selector){context.next_engine=location.attr("data-engine");if(options.clone===false){return location.remove()[0].innerHTML.toString()}else{return location[0].innerHTML.toString()}}}})},loadPartials:function(partials){var name;if(partials){this.partials=this.partials||{};for(name in partials){(function(context,name){context.load(partials[name]).then(function(template){this.partials[name]=template})})(this,name)}}return this},render:function(location,data,callback,partials){if(_isFunction(location)&&!data){return this.then(location)}else{if(_isFunction(data)){partials=callback;callback=data;data=null}else if(callback&&!_isFunction(callback)){partials=callback;callback=null}return this.loadPartials(partials).load(location).interpolate(data,location).then(callback)}},partial:function(location,data,callback,partials){if(_isFunction(callback)){return this.render(location,data,partials).swap(callback)}else if(_isFunction(data)){return this.render(location,{},callback).swap(data)}else{return this.render(location,data,callback).swap()}},send:function(){var context=this,args=_makeArray(arguments),fun=args.shift();if(_isArray(args[0])){args=args[0]}return this.then(function(content){args.push(function(response){context.next(response)});context.wait();fun.apply(fun,args);return false})},collect:function(array,callback,now){var context=this;var coll=function(){if(_isFunction(array)){callback=array;array=this.content}var contents=[],doms=false;$.each(array,function(i,item){var returned=callback.apply(context,[i,item]);if(returned.jquery&&returned.length==1){returned=returned[0];doms=true}contents.push(returned);return returned});return doms?contents:contents.join("")};return now?coll():this.then(coll)},renderEach:function(location,name,data,callback){if(_isArray(name)){callback=data;data=name;name=null}return this.load(location).then(function(content){var rctx=this;if(!data){data=_isArray(this.previous_content)?this.previous_content:[]}if(callback){$.each(data,function(i,value){var idata={},engine=this.next_engine||location;if(name){idata[name]=value}else{idata=value}callback(value,rctx.event_context.interpolate(content,idata,engine))})}else{return this.collect(data,function(i,value){var idata={},engine=this.next_engine||location;if(name){idata[name]=value}else{idata=value}return this.event_context.interpolate(content,idata,engine)},true)}})},interpolate:function(data,engine,retain){var context=this;return this.then(function(content,prev){if(!data&&prev){data=prev}if(this.next_engine){engine=this.next_engine;this.next_engine=false}var rendered=context.event_context.interpolate(content,data,engine,this.partials);return retain?prev+rendered:rendered})},swap:function(callback){return this.then(function(content){this.event_context.swap(content,callback);return content}).trigger("changed",{})},appendTo:function(selector){return this.then(function(content){$(selector).append(content)}).trigger("changed",{})},prependTo:function(selector){return this.then(function(content){$(selector).prepend(content)}).trigger("changed",{})},replace:function(selector){return this.then(function(content){$(selector).html(content)}).trigger("changed",{})},trigger:function(name,data){return this.then(function(content){if(typeof data=="undefined"){data={content:content}}this.event_context.trigger(name,data);return content})}});Sammy.EventContext=function(app,verb,path,params,target){this.app=app;this.verb=verb;this.path=path;this.params=new Sammy.Object(params);this.target=target};Sammy.EventContext.prototype=$.extend({},Sammy.Object.prototype,{$element:function(){return this.app.$element(_makeArray(arguments).shift())},engineFor:function(engine){var context=this,engine_match;if(_isFunction(engine)){return engine}engine=(engine||context.app.template_engine).toString();if(engine_match=engine.match(/\.([^\.\?\#]+)(\?|$)/)){engine=engine_match[1]}if(engine&&_isFunction(context[engine])){return context[engine]}if(context.app.template_engine){return this.engineFor(context.app.template_engine)}return function(content,data){return content}},interpolate:function(content,data,engine,partials){return this.engineFor(engine).apply(this,[content,data,partials])},render:function(location,data,callback,partials){return new Sammy.RenderContext(this).render(location,data,callback,partials)},renderEach:function(location,name,data,callback){return new Sammy.RenderContext(this).renderEach(location,name,data,callback)},load:function(location,options,callback){return new Sammy.RenderContext(this).load(location,options,callback)},loadPartials:function(partials){return new Sammy.RenderContext(this).loadPartials(partials)},partial:function(location,data,callback,partials){return new Sammy.RenderContext(this).partial(location,data,callback,partials)},send:function(){var rctx=new Sammy.RenderContext(this);return rctx.send.apply(rctx,arguments)},redirect:function(){var to,args=_makeArray(arguments),current_location=this.app.getLocation(),l=args.length;if(l>1){var i=0,paths=[],pairs=[],params={},has_params=false;for(;i<l;i++){if(typeof args[i]=="string"){paths.push(args[i])}else{$.extend(params,args[i]);has_params=true}}to=paths.join("/");if(has_params){for(var k in params){pairs.push(this.app._encodeFormPair(k,params[k]))}to+="?"+pairs.join("&")}}else{to=args[0]}this.trigger("redirect",{to:to});this.app.last_location=[this.verb,this.path];this.app.setLocation(to);if(new RegExp(to).test(current_location)){this.app.trigger("location-changed")}},trigger:function(name,data){if(typeof data=="undefined"){data={}}if(!data.context){data.context=this}return this.app.trigger(name,data)},eventNamespace:function(){return this.app.eventNamespace()},swap:function(contents,callback){return this.app.swap(contents,callback)},notFound:function(){return this.app.notFound(this.verb,this.path)},json:function(string){return $.parseJSON(string)},toString:function(){return"Sammy.EventContext: "+[this.verb,this.path,this.params].join(" ")}});return Sammy});;
$(function () {
    window.router = function () {
        var self = {};

        // НАСТРОЙКИ РУТЕРА
        self.requestId = null; // идентификатор поиска
        self.active = null; // конфигурация активного в настоящий момент шага
        self.$preloader = $("div[router-role='preloader']"); // элемент прелоадера
        self.$routerContainer = $("div[router='true']"); // контейнер маршрутизатора

        //усыпляет поток на указанное количество млсек
        self.delay = async function (ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        };

        //поворот баннера
        self.flip = async function ($source, $target) {
            //Скрываем $source
            if (jv3.utils.various.detectAppleDevice()) {
                // отключаем transition для iPhone и iPad, на 14.2 он здесь падает жёстко, убивая страницу целиком
                $source.removeClass("flip-in").addClass("flip-out");
            }
            else {
                await $source.removeClass("flip-in").addClass("flip-out").waitTransitionEnd();
            }
            $source.addClass("hide");

            //Показываем $target
            $target.removeClass("hide");
            if (jv3.utils.various.detectAppleDevice()) {
                // отключаем transition для iPhone и iPad, на 14.2 он здесь падает жёстко, убивая страницу целиком
                $target.removeClass("flip-out").addClass("flip-in");
            }
            else {
                await jv3.utils.various.sleep(1); //задержка необходима почему-то, видимо фича браузера
                await $target.removeClass("flip-out").addClass("flip-in").waitTransitionEnd();
            }
        };

        // оповещает об ошибке через alert и возвращает false
        self.error = function (message) {
            console.error(message);
            alert('SEARCHROUTER.ES6.JS ERROR: ' + message);
            return false;
        };

        // движение ВПЕРЕД
        self.next = function () {
            if (!self.active)
                throw "No active step is selected";
            self.active.model.model.isModelFlipped = true;
            location.hash = self.active.next + "/" + self.requestId;
        };

        // движение НАЗАД
        self.prev = function () {
            if (!self.active)
                throw "No active step is selected";
            if (self.active.prev === undefined && self.active.hash !== location.hash) {// первый шаг не имеет prev
                location.hash = self.active.hash + "/" + self.requestId;
            }
            else
                location.hash = self.active.prev + "/" + self.requestId;
        };

        self.show = function (target) {
            target.model.model.isModelFlipped = false;
            target.model.onShow();
            target.model.model.isModelActive = true;
        };

        self.load = async function (controller, action, hash) {
            var target = self.getStepSettings(controller, action); // шаг, на который надо перейти
            if (self.active && self.active.model.isLoaded) { // был активный ранее шаг - его надо скрыть и открыть прелоадер
                // если движение не вперед (назад на сколько угодно шагов) - надо у актива сделать очистку
                // но если хэш актива равен хэшу таргета, значит происходит возврат к предыдущему шагу, когда следующий не загрузился
                if (self.active.next !== target.hash && self.active.hash !== target.hash) {
                    if (typeof self.active.model.unload === "function") {
                        self.active.model.unload(); // выгрузка старого шага
                        self.unloadAllModelsButTarget(target);
                    }
                }
                if (target.model && target.model.isLoaded) { // если нужный шаг загружен - флип в него
                    if (self.active.$el.attr("id") === target.$el.attr("id")) {
                        // возврат при ошибке
                        await self.flip(self.$preloader, target.$el);
                    }
                    else { // классический переход
                        await self.flip(self.active.$el, target.$el);
                    }
                    self.show(target);
                }
                else {
                    await self.flip(self.active.$el, self.$preloader);
                }
                self.active.model.model.isModelActive = false;
            }
            else if (self.active && !self.active.model.isLoaded && self.active.hash === target.hash) { // активный шаг загружен, но был запрос на апдейт его

                await self.flip(self.active.$el, self.$preloader); // флип в прелоадер для перегрузки текущего шага
            }

            if (!target.model || !target.model.isLoaded) {

                let data = null;
                try { 
                    const target_url = window.globals.AbsolutePath + "/" + controller.replace(".", "/") + "/" + action;
                    if (target.input) {
                        data = (await axios.post(target_url, target.input)).data;
                    }
                    else {
                        data = (await axios.get(target_url, { params: { hash: hash } })).data;
                    }
                }
                catch (error) {
                    if (!isPreloaderActive()) return;
                    window.addEventListener('window.jv3.utils.various.error.confirm', function _loadStepErrorConfirmHandler() {
                        window.removeEventListener("window.jv3.utils.various.error.confirm", _loadStepErrorConfirmHandler); // удаляем слушателя что бы небыло ложных срабатываний в дальнейшем                       
                        if (!isPreloaderActive()) return;
                        self.flip(self.$preloader, self.active.$el);
                    });
                    location.hash = self.active.hash + "/" + self.requestId;
                    return;
                }
                if (!isPreloaderActive()) return;
                target.$el.html(data); // биндим данные, которые пришли с сервера
                const json = $("div[data-json]", target.$el).data("json");
                if (!target.model)
                    return self.error("Model required to load was not loaded: check if the script is included in bundle");
                if (typeof target.model.load !== "undefined") { // если у шага есть функция загрузки
                    await target.model.load(json);
                }

                self.active = target;

                await self.flip(self.$preloader, target.$el);
                await self.delay(100); //пауза для инициализации всех объектов модели
                self.show(target);
            }
            else
                self.active = target;
        };

        //устанавливает флаг "невыгруженности" для всех страниц, кроме целевой. Так убирается кеш страниц
        self.unloadAllModelsButTarget = function (target) {
            let containers = $("div[router='true']").children("div[router-model]").not(target.$el);

            for (var i = 0; i < containers.length; i++) {//for..of некорректно бабелизируется для ie11, альтернатива
                var container = containers[i];
                const model = self.getObject($(container), "router-model");
                model.isLoaded = false;
                if (model.model) {
                    model.model.isModelActive = false;
                }
            }
        };

        // получение настроек шага, которые берутся из атрибутов рутера -- router-something
        // пример атрибутов: 
        // <div router-model="window.search.hotel.variants" router-role="step" router-id="hotel-variants" router-hash="#hotel/variants" router-next="hotel-rates" router-prev="hotel-index">
        self.getStepSettings = function (controller, action) {
            let hash = "#" + controller + "/" + action;
            var $container =
                $("div[router='true'] div[router-hash='" + hash + "']:first"); // получить див, соответствующий текущему хэшу
            if ($container.length === 0) {
                console.log("div[router='true'] div[router-hash='" + hash + "'] was not found in DOM!");
                return null;
            }
            if (!window.search)
                window.search = {}; // защита от некорректной инициализации, когда рутер загрузился, а контейнер отеля ещё пустой
            return {
                $el: $container,
                hash: $container.attr("router-hash"),
                next: $container.attr("router-next"),
                prev: $container.attr("router-prev"),
                model: self.getObject($container, "router-model"),
                input: self.getObject($container, "router-input")
            };
        };

        // вытаскивает объект или возвращает нулл, если объекта не существует
        self.getObject = function ($container, path) {
            try {
                return eval($container.attr(path));
            } catch (err) {
                return null;
            }
        };

        self.init = function () {
            if (!location.hash) { // этот блок нужен для того случая, когда к рутеру обратятся без хэша - кинуть на стартовый пейдж в этом случае
                window.location = self.$routerContainer.attr("router-start");
            }
            self.sammy = Sammy('#main', function () {
                this.get('#:controller/:action/:hash', function (context) {
                    if (!context.params.controller)
                        return self.error("empty CONTROLLER(first) mandatory param in window.location.hash!");
                    if (!context.params.action)
                        return self.error("empty ACTION(second) mandatory param in window.location.hash!");
                    if (!context.params.hash)
                        return self.error("empty HASH(third) mandatory param in window.location.hash!");
                    self.requestId = context.params.hash;
                    self.load(context.params.controller, context.params.action, context.params.hash);
                });
            });
            self.sammy.run(location.hash);
        };
        //проверить, активен ли прелоадер, подробнее в corteos.megaplan.ru/event/1023489/card/
        function isPreloaderActive() {
            return self.$preloader.hasClass("flip-in");
        }

        return self;
    }();

    window.router.init();
});;
// базовый класс, от которого наследует любая модель шага
function baseStepModel() {

    var self = {};

    self.isLoaded = false; // статус загруженности шага

    // метод, выполняющийся при загрузке шага
    self.load = function (json) {
        self.isLoaded = true;
        self.onLoad(json);
        self.model.isModelActive = true;
    };

    // обязательный для оверрайда в наследнике метод загрузки
    self.onLoad = function (json) {
        throw "onLoad function must be overloaded";
    };


    // метод, выполняющийся при выгрузке шага
    self.unload = function () {
        self.isLoaded = false;
        self.onUnload();
    };

    // обязательный для оверрайда в наследнике метод выгрузки
    self.onUnload = function (json) {
        throw "onUnload function must be overloaded";
    };

    self.onShow = function () {
        throw "onShow function must be overloaded";
    };

    

    return self;
}
;
// МОДЕЛЬ СТРАНИЦЫ ВЫБОРА: Командировки, сервис тима, плательщика
// Используется во вьюхах:
//          Pages\Search\PrebookingComplex\Views\Desktop\Index.cshtml
//          Pages\Search\PrebookingComplex\Views\Mobile\Index.cshtml
function prebookingComplexModel(json) {
    const mixins = [...window.jv3.utils.mixins.retrieveMixings('prebooking-v2')];
    if (!window.globals.IsMobileVersion) {
        mixins.push(paxEditorMixin);
    }
    
    // формируется модель для vue.js
    var vm = {
        el: "#prebooking-complex",
        mixins: mixins,
        data() {
            return {
                settings: json, // настройки формы пребукинга
                // пути к контроллерам для каждого из шагов
                stepControllers: JSON.parse(document.getElementById("prebooking-complex").dataset.stepControllers),
                // имена шагов по порядку
                stepNames: JSON.parse(document.getElementById("prebooking-complex").dataset.stepNames),
                // настройки для работы с фронтом
                frontEnd: {
                    showBottomBlockWithBigButton: true, // показывать блок, который прибит снизу с кнопкой создания заказа
                    currentStepId: 0, // индекс текущего шага
                    currentStepMobileId: 0, // индекс текущего шага в мобильной версии
                    total: {
                        price: 0,
                        isApproximate: false,
                        isLoading: true
                    },
                    allowAutoScrollToBottom: true,//после выбора шага страница прокручивается вниз
                },
                // шаги пребукинга, например, сервистимы и пассажира
                steps: {},
                // модель создаваемого заказа
                sendToBackend: {
                    requestId: json.requestId,
                    details: JSON.parse(document.getElementById("prebooking-complex").dataset.newReserveDetails),
                    selectedPaxes: []
                }
            };
        },

        mounted() {
            // запускаем следующим тиком, чтобы все табы успели сформироваться
            this.$nextTick(() => {
                // показываем все не влияющие ни на что блоки
                for (const name of this.stepNames) {
                    const current = 'is' + name.slice(0, 1).toUpperCase() + name.slice(1) + 'Completed';
                    this.$watch(current, (val) => this.changeStepState(val, name));

                    if (this.isStepCompleted(name)) {
                        this.next(name);
                    }
                }
            });

        },

        computed: {
            isAllStepsCompleted() {
                let result = true;
                for (const stepName in this.steps) {
                    result = result && this.isStepCompleted(stepName);
                }
                return result;
            },

            // модель текущего шага
            currentStep() {
                return this.steps[this.currentStepName];
            },

            // название текущего шага - поле из контейнера this.steps
            currentStepName() {
                return this.frontEnd.currentStepId < this.stepNames.length
                    ? this.stepNames[this.frontEnd.currentStepId]
                    : this.stepNames.at(-1);
            },
        },

        methods: {
            changeStepState(state, stepName) {
                const stepIndex = this.stepNames.indexOf(stepName);
                if (this.frontEnd.currentStepId < stepIndex) {
                    return;
                }

                if (state === false && this.frontEnd.currentStepId > stepIndex) {
                    this.frontEnd.currentStepId = stepIndex;
                    return;
                }

                if (this.isStepCompleted(stepName)) {
                    this.next(stepName);
                }
            },

            isStepCompleted(stepName) {
                const current = 'is' + stepName.slice(0, 1).toUpperCase() + stepName.slice(1) + 'Completed';
                const res = this[current];
                if (res === undefined || typeof res === 'function') {
                    console.error(`Не определено свойство${current}' - его необходимо определить для шага ${stepName} пребукинга.`);
                    return false;
                }
                else {
                    return !!res && (!window.globals.IsMobileVersion || this.frontEnd.currentStepMobileId >= this.frontEnd.currentStepId);
                }
            },

            //сумму в красивую строку
            getCurrencyString(sum) {
                return jv3.utils.various.getCurrencyString(sum);
            },

            goToStep(name) {
                this.frontEnd.currentStepId = this.stepNames.findIndex(x => x === name);
            },

            objectToArray(obj) {
                return Object.entries(obj).map(([k, v]) => ({ key: k, value: v }));
            },

            // переход на следующий шаг, если передано имя name, то будет переход на следующий по отношению к шагу с именем name шагу
            async next(name) {
                this.frontEnd.needNextStepMobile = false;
                if (!name) {
                    // просто переход на следующий шаг относительно текущего
                    this.frontEnd.currentStepId++;
                }
                else {
                    // переход на следующий шаг относительно переданного
                    this.frontEnd.currentStepId = this.stepNames.findIndex(x => x === name) + 1;
                }
            },

            //создание заказа
            async createNewReserve(withSwal = true) {

                try {

                    if (withSwal)  swal.showLoading();
                    const data = (await axios.post(window.globals.AbsolutePath +"/PrebookingComplex/CreateNewReserve", this.sendToBackend)).data;
					
                    if (data.validationErrors) {
                        if (withSwal) swal.close();                   
                        window.jv3.utils.various.error(data.validationErrors.map(x => x.errors.join(', ')).join('<br />'));
                        this.steps.paxSelector.serverResponse.paxes.forEach(p => p.validationErrors = []); // очистка старых ошибок
                        for (validationResult of data.validationErrors) { //логика рендеринга ошибок валидации
                            const pax = this.steps.paxSelector.serverResponse.paxes.find(p => p.id === validationResult.id_Person);
                            if (pax) {
                                pax.validationErrors = validationResult.errors;
                            }
                        }
                    }
                    else { //перенаправить на страницу командировки
                        window.location = window.globals.AbsolutePath + '/ComplexDetails/?from=prebooking&id=' + this.sendToBackend.details.id_ComplexReserve;
                    }
                }
                catch (err) { }
            },

            scrollToTab(tabName) {
                setTimeout(() => {
                    const element = document.getElementById("prebooking-step-" + tabName);
                    if (element) {
                        element.scrollIntoView({ behavior: "smooth" });
                    }
                }, 200);
            },

            scrollToEnd() {
                if (!window.globals.IsMobileVersion && !!this.frontEnd.allowAutoScrollToBottom) {
                    setTimeout(() => {
                        window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                    }, 200);
                }
            }
        },

        watch: {
            'currentStepName': function (val) {
                this.changeStepState(null, val);
            },

            'frontEnd.currentStepId': function (val, oldVal) {
                if (val > oldVal) {
                    this.scrollToEnd();
                }
            }
        }
    };
    return vm;
}

// инициализация контейнера для js-моделей
window.namespace("search.prebooking").complex = function () {
    var self = new baseStepModel();

    self.model = null; // модель данных пока пустая - она будет сформирована в методe onLoad

    self.onLoad = function (json) {
        self.model = new Vue(new prebookingComplexModel(json));
    };

    // вызывается при показе шага
    self.onShow = function () {
        window.scrollTo(0, 0);
    };

    //Переопределяем шаг выгрузки, очищая бандинги
    self.onUnload = function () {
    };

    return self;
}();
;
