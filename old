using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Claims;
using HAS.Modules.UAS.Services;
using HAS.Server.Commons.Supervision;
using HAS.Server.Commons.Time;
using IdentityServer4.Configuration;
using IdentityServer4.EntityFramework.Options;
using IdentityServer4.ResponseHandling;
using IdentityServer4.Services;
using IdentityServer4.Test;
using Mega.Has.Commons;
using Mega.Has.Commons.Security;
using Mega.Has.Modules.UAS;
using Mega.Has.Modules.UAS.Hopex;
using Mega.Has.Modules.UAS.Models;
using Mega.Has.Modules.UAS.Providers;
using Mega.Has.Modules.UAS.Providers.Google;
using Mega.Has.Modules.UAS.Providers.Saml2;
using Mega.Has.Modules.UAS.Services;
using Mega.Has.Modules.UAS.Stores;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.HttpOverrides;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.IdentityModel.Tokens;
using Serilog;

namespace HAS.Modules.UAS.Extensions
{
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection ConfigureForwardedHeaders(this IServiceCollection services)
        {
            services.Configure<ForwardedHeadersOptions>(options =>
            {
                options.ForwardedHeaders = ForwardedHeaders.All;
                options.KnownNetworks.Clear();
                options.KnownProxies.Clear();
            });
            return services;
        }

        public static IServiceCollection ConfigureWindowsAuthentication(this IServiceCollection services)
        {
            if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            {
                services.AddAuthentication("Windows");
                
                var requireWindowsProviderPolicy = new AuthorizationPolicyBuilder()
                    .RequireClaim("http://schemas.microsoft.com/identity/claims/identityprovider", "Windows")
                    .Build();
                
                services.AddAuthorization(options =>
                {
                    options.AddPolicy("RequireWindowsProviderPolicy", requireWindowsProviderPolicy);
                });
            }
            return services;
        }

        public static IServiceCollection ConfigureUAS(this IServiceCollection services)
        {
            // Инициализация HAS модуля и получение конфигурации
            var cryptoService = services.AddHASModule("DFBD9B76-B44D-44EC-86C2-81C5F6BE2C47", opts =>
            {
                opts.ConfigureAuthorization = options =>
                {
                    options.AddPolicy("Administrator", policy =>
                    {
                        policy.RequireAuthenticatedUser()
                            .RequireAssertion(ctx =>
                            {
                                try
                                {
                                    return ctx.User.Identity.AuthenticationType == "InternalApiKeyScheme" ||
                                           ctx.User.IsAuthorizedForModule("has.uas") ||
                                           string.Compare(ctx.User.FindFirstValue("sub"), "admin", StringComparison.OrdinalIgnoreCase) == 0;
                                }
                                catch
                                {
                                    return false;
                                }
                            });
                    });
                };
            });

            var serverConfigurations = cryptoService.Configuration;

            // ИСПРАВЛЕНИЕ: Добавляем DbContext с явным типом (замените ApplicationDbContext на ваш тип)
            services.AddDbContext<ApplicationDbContext>((serviceProvider, options) =>
            {
                ResolveDbOptions(serverConfigurations, options, "application");
            }, ServiceLifetime.Scoped, ServiceLifetime.Scoped);

            // Регистрация сервисов
            services.AddSingleton<ILoginResolver, LoginResolver>();
            services.AddSingleton<IHttpContextAccessor, HttpContextAccessor>();
            services.AddScoped<IExternalProviderService, ExternalProviderService>();
            services.AddScoped<IClientService, ClientService>();
            services.AddScoped<IAccessTokenService, AccessTokenService>();
            services.AddSingleton<ICurrentDateTimeProvider, CurrentDateTimeProvider>();
            services.AddSingleton<ISupervisionServices, SupervisionServices>();
            services.AddSingleton<IAuthenticationFailureRepository, AuthenticationFailureRepository>();
            services.AddSingleton<IAuthenticationFailureHandlingService, AuthenticationFailureHandlingService>();
            services.AddScoped<ITokenRevocationResponseGenerator, UasTokenRevocationResponseGenerator>();
            services.AddSingleton<ICorsPolicyService, CorsPolicyService>();
            services.AddHostedService<CorsOriginsService>();

            // Настройка IdentityServer
            var identityServerBuilder = services.AddIdentityServer(options =>
            {
                options.Events.RaiseErrorEvents = true;
                options.Events.RaiseInformationEvents = true;
                options.Events.RaiseFailureEvents = true;
                options.Events.RaiseSuccessEvents = true;
                options.Csp.AddDeprecatedHeader = false;
                options.IssuerUri = cryptoService.Configuration.RuntimeClusterSettings.GetValidIssuer();
                options.Cors.CorsPaths.Add("/Account/ExternalLogin");
                options.Cors.CorsPaths.Add("/Account/Login");
                options.UserInteraction.ErrorUrl = "/account/error";
            })
            .AddConfigurationStore(options =>
            {
                options.ResolveDbContextOptions = (serviceProvider, o) =>
                {
                    ResolveDbOptions(serverConfigurations, o, "uasConfiguration");
                };
            })
            .AddOperationalStore(options =>
            {
                options.ResolveDbContextOptions = (serviceProvider, o) =>
                {
                    ResolveDbOptions(serverConfigurations, o, "uasGrant");
                };
                options.EnableTokenCleanup = true;
                options.TokenCleanupBatchSize = 500;
            })
            .AddSigningCredential(new SigningCredentials(
                new RsaSecurityKey(cryptoService.PrivateKey), 
                SecurityAlgorithms.RsaSha256))
            .AddHopexUsers();

            // Настройка провайдеров
            if (ShouldUseInMemoryDatabase(serverConfigurations))
            {
                // In-Memory режим (для тестирования)
                identityServerBuilder
                    .AddInMemoryApiResources(DefaultConfiguration.GetApiResources())
                    .AddInMemoryApiScopes(DefaultConfiguration.GetApiScopes())
                    .AddInMemoryClients(DefaultConfiguration.GetClients(cryptoService.Configuration.RuntimeClusterSettings))
                    .AddInMemoryIdentityResources(DefaultConfiguration.GetIdentityResources())
                    .AddTestUsers(DefaultConfiguration.GetAccessTokens(null)
                        .Select(u => new TestUser
                        {
                            ProviderName = u.ProviderName,
                            Username = u.TokenName,
                            SubjectId = u.TokenName,
                            IsActive = true,
                            Claims = u.Claims.ToList(),
                            Password = u.Password
                        })
                        .ToList());
            }
            else if (ModuleConfiguration.Instance.RunningInHASContext)
            {
                // Рабочий режим с БД
                var authenticationBuilder = services.AddAuthentication();
                services.AddScoped<IExternalProvider, OpenIdProvider>();
                services.AddScoped<IExternalProvider, Saml2Provider>();

                // ИСПРАВЛЕНИЕ: Создаем scope правильно
                var serviceProvider = services.BuildServiceProvider();
                using (var scope = serviceProvider.CreateScope())
                {
                    var scopedServices = scope.ServiceProvider;
                    
                    // ИСПРАВЛЕНИЕ: Инициализируем seed data внутри scope
                    SeedData.EnsureSeedData(services, cryptoService.Configuration, authenticationBuilder);
                    
                    ConfigureExternalProviders(services, serviceProvider, serverConfigurations, authenticationBuilder);
                }
            }

            return services;
        }

        private static void ConfigureExternalProviders(
            IServiceCollection serviceCollection,
            ServiceProvider services,
            IClusterConfiguration serverConfigurations,
            AuthenticationBuilder authenticationBuilder)
        {
            var providers = services.GetServices<IExternalProvider>();
            if (providers != null)
            {
                foreach (var provider in providers)
                {
                    try
                    {
                        Log.Information($"Using external provider {provider.GetType().Name}");
                        p
